

=================================================
저장한 시간: 2025-03-11 오후 1:49:20 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// save 파일로 분리 / template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <vector>
//#include <algorithm>
#include <chrono>
void save( std::string_view );


int main()
{

	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 1:54:34 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// save 파일로 분리 / template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"

// [문제] main에서 의도대로 실행되게


int main()
{

	int a{ 1 }, b{ 2 };

	save("main.cpp");
	save("save.h");
	save("save.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 1:54:34 화요일
=================================================

#pragma once
//---------------------------------------------------------------
// save.h								2025년 3월 11일
// 
// --------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

=================================================
저장한 시간: 2025-03-11 오후 1:54:34 화요일
=================================================

//---------------------------------------------------------------
// save.cpp								2025년 3월 11일
// 
// 한 학기 강의를 덧붙여 저장하는 함수이다.
// --------------------------------------------------------------
#include "save.h"

void save(std::string_view fileName)
{
	// fileName을 읽기모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다" << std::endl;
		exit(20250306);
	}

	// 쓰기모드로 저장할 파일을 연다
	std::string nameForSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameForSave , std::ios::app };

	// 저장했다고 화면 출력

	auto size = std::filesystem::file_size(fileName);
	std::cout << nameForSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << "Bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();				// time_point를 얻는다. epoch
	auto utc = std::chrono::system_clock::to_time_t(now);		// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);			// 원 locale을 복구

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::vector<char> v(size);
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 1:59:45 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// save 파일로 분리 / template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] main에서 의도대로 실행되게


template <typename T>
void change(T& a, T& b) {
	T temp = a;
	b = a;
	a = temp;
}

int main()
{

	int a{ 1 }, b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	save("main.cpp");
	save("save.h");
	save("save.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 1:59:45 화요일
=================================================

#pragma once
//---------------------------------------------------------------
// save.h								2025년 3월 11일
// 
// --------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

=================================================
저장한 시간: 2025-03-11 오후 1:59:45 화요일
=================================================

//---------------------------------------------------------------
// save.cpp								2025년 3월 11일
// 
// 한 학기 강의를 덧붙여 저장하는 함수이다.
// --------------------------------------------------------------
#include "save.h"

void save(std::string_view fileName)
{
	// fileName을 읽기모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다" << std::endl;
		exit(20250306);
	}

	// 쓰기모드로 저장할 파일을 연다
	std::string nameForSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameForSave , std::ios::app };

	// 저장했다고 화면 출력

	auto size = std::filesystem::file_size(fileName);
	std::cout << nameForSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << "Bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();				// time_point를 얻는다. epoch
	auto utc = std::chrono::system_clock::to_time_t(now);		// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);			// 원 locale을 복구

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::vector<char> v(size);
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 2:00:02 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// save 파일로 분리 / template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] main에서 의도대로 실행되게


template <typename T>
void change(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}

int main()
{

	int a{ 1 }, b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	save("main.cpp");
	save("save.h");
	save("save.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 2:00:02 화요일
=================================================

#pragma once
//---------------------------------------------------------------
// save.h								2025년 3월 11일
// 
// --------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

=================================================
저장한 시간: 2025-03-11 오후 2:00:02 화요일
=================================================

//---------------------------------------------------------------
// save.cpp								2025년 3월 11일
// 
// 한 학기 강의를 덧붙여 저장하는 함수이다.
// --------------------------------------------------------------
#include "save.h"

void save(std::string_view fileName)
{
	// fileName을 읽기모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다" << std::endl;
		exit(20250306);
	}

	// 쓰기모드로 저장할 파일을 연다
	std::string nameForSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameForSave , std::ios::app };

	// 저장했다고 화면 출력

	auto size = std::filesystem::file_size(fileName);
	std::cout << nameForSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << "Bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();				// time_point를 얻는다. epoch
	auto utc = std::chrono::system_clock::to_time_t(now);		// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);			// 원 locale을 복구

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::vector<char> v(size);
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 2:03:07 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// save 파일로 분리 / template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] main을 수정하지 않고 의도대로 실행되게

void change(int&, int&);

int main()
{

	int a{ 1 }, b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	save("main.cpp");
	save("save.h");
	save("save.cpp");
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

=================================================
저장한 시간: 2025-03-11 오후 2:03:07 화요일
=================================================

#pragma once
//-----------------------------------------------------------------------------
// save.h								2025년 3월 11일
// ----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

=================================================
저장한 시간: 2025-03-11 오후 2:03:07 화요일
=================================================

//---------------------------------------------------------------
// save.cpp								2025년 3월 11일
// 
// 한 학기 강의를 덧붙여 저장하는 함수이다.
// --------------------------------------------------------------
#include "save.h"

void save(std::string_view fileName)
{
	// fileName을 읽기모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다" << std::endl;
		exit(20250306);
	}

	// 쓰기모드로 저장할 파일을 연다
	std::string nameForSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameForSave , std::ios::app };

	// 저장했다고 화면 출력

	auto size = std::filesystem::file_size(fileName);
	std::cout << nameForSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << "Bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();				// time_point를 얻는다. epoch
	auto utc = std::chrono::system_clock::to_time_t(now);		// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);			// 원 locale을 복구

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::vector<char> v(size);
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 2:27:04 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// save 파일로 분리 / template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] main을 수정하지 않고 의도대로 실행되게

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

void change(Dog&, Dog&);
void change(int&, int&);

int main()
{
	{
		Dog a{1}, b{2};
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}


void change(Dog& a, Dog& b) {
	Dog temp{ a };
	a = b;
	b = temp;
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

=================================================
저장한 시간: 2025-03-11 오후 2:33:27 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

void change(Dog&, Dog&);
void change(int&, int&);

int main()
{
	{
		Dog a{1}, b{2};
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}


void change(Dog& a, Dog& b) {
	Dog temp{ a };
	a = b;
	b = temp;
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

=================================================
저장한 시간: 2025-03-11 오후 2:33:43 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

void change(Dog&, Dog&);
void change(int&, int&);

int main()
{
	{
		Dog a{1}, b{2};
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}


void change(Dog& a, Dog& b) {
	Dog temp{ a };
	a = b;
	b = temp;
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

=================================================
저장한 시간: 2025-03-11 오후 2:36:46 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

template <class T>
void change(T&, T&);

int main()
{
	{
		Dog a{1}, b{2};
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}

template <class T>
void change(T& a, T& b) {
	T temp{ a };
	a = b;
	b = temp;
}

=================================================
저장한 시간: 2025-03-11 오후 2:41:14 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

template <class T>
void change(T& a, T& b) {
	T temp{ a };
	a = b;
	b = temp;
}

int main()
{
	std::cout << "Dog의 크기 = " << sizeof(Dog);
	{
		Dog a{1}, b{2};
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 2:53:51 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

template <class T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

template <>
void change(Dog& a, Dog& b)
{
	Dog temp{ a };
	a = b;
	b = temp;
}

template <>
void change(int& a, int& b)
{
	int temp{ a };
	a = b;
	b = temp;
}

int main()
{
	{
		Dog a{1}, b{2};
		change(a, b);
		// 1. change( Dog, Dog );
		// 2. change( Dog&, Dog& );
		// 3. 컴파일러가 template을 이용하여 코드 생성
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 2:55:03 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

template <class T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

int main()
{
	{
		Dog a{1}, b{2};
		change(a, b);
		// 1. change( Dog, Dog );
		// 2. change( Dog&, Dog& );
		// 3. 컴파일러가 template을 이용하여 코드 생성
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 2:55:22 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함


int main()
{
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 2:59:43 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// 랜덤 int 1000개를 화면에 출력하라

void printRandomInt() {
	std::random_device rd;
	std::uniform_int_distribution<int> randomNumber(0, 9);
	
	for (int i = 0; i < 1000; i++) {
		std::cout << randomNumber << '\n';
	}
}

int main()
{
	printRandomInt();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 3:00:33 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// 랜덤 int 1000개를 화면에 출력하라

void printRandomInt() {
	std::random_device rd;
	std::uniform_int_distribution<int> uid (0, 9);
	
	for (int i = 0; i < 1000; i++) {
		std::cout << uid(rd) << '\n';
	}
}

int main()
{
	printRandomInt();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 3:06:08 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// 랜덤 int 1000개를 화면에 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{ 0,9999999 };

int main()
{
	for (int i = 0; i < 1000; ++i) {
		std::cout << uid(dre) << " ";
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 3:08:13 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// 랜덤 int 1000개를 화면에 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{ 0,9999999 };

int main()
{
	for (int i = 0; i < 1000; ++i) {
		std::print("{:8}", uid(dre));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 11:20:24 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{ 0,9999999 };

int main()
{
	for (int i = 0; i < 1000; ++i) {
		std::print("{:8}", uid(dre));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 11:32:24 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{ 0,9999999 };

int main()
{
	for (int i = 0; i < 1000; ++i) {
		std::print("{:8}", uid(dre));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 3:35:39 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	for (int i = 0; i < 1000; ++i) {
		std::print("{:8}", uid(dre));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 3:38:22 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	for (int i = 0; i < 1000; ++i) {
		std::print("{:8}", uid(dre));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 3:51:56 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };




int main()
{
	// T[N]
	int arr[ 1'000 ];

	for (int i = 0; i < 1000; ++i) {
		arr[i] = uid(dre);
	}

	int maxValue{ std::numeric_limits<int>::min() };

	for (int i = 0; i < 1000; ++i) {
		if (arr[i] > maxValue)
			maxValue = arr[i];
	}

	std::cout << "최댓값 = " << maxValue << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:09:54 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };




int main()
{
	std::array<int, 1000> arr;						// T[N] ---> array<T,N>

	for ( int& num : arr )			// magic number, hard-wired
		num = uid(dre);

	auto 위치 = std::max_element(arr.begin(), arr.end());


	std::cout << "최댓값 = " << *위치 << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:11:10 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };




int main()
{
	std::array<int, 1000> arr;						// T[N] ---> array<T,N>

	for (int& num : arr)			// magic number, hard-wired
		num = uid(dre);

	std::cout << "최댓값 = " << *(std::max_element(arr.begin(), arr.end())) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:26:06 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <array>
#include <algorithm>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::print("(:80)", 20250311);

	/*for (int i = 0; i < 1'000; ++i) {
		std::print("(:8)", uid(dre));
	}*/


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:26:30 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <array>
#include <algorithm>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::print("(:80)", 20250311);

	/*for (int i = 0; i < 1'000; ++i) {
		std::print("(:8)", uid(dre));
	}*/


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:27:06 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::print("(:80)", 20250311);

	/*for (int i = 0; i < 1'000; ++i) {
		std::print("(:8)", uid(dre));
	}*/


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:31:23 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	for (int i = 0; i < 1'000; ++i)
		std::print(out, "{:8}", uid(dre));


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:32:28 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	for (int i = 0; i < 1'000; ++i)
		std::print(out, "{:8}", uid(dre));


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:32:45 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	for (int i = 0; i < 1'000; ++i)
		std::print(out, "{:8}", uid(dre));


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:36:32 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	for (int i = 0; i < 1'000; ++i)
		std::print(out, "{:8}", uid(dre));

	/*std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ"<<'\n';
		exit(-1);
	}*/



	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:37:23 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	for (int i = 0; i < 1'000; ++i)
		std::print(out, "{:8} ***", uid(dre));

	/*std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ"<<'\n';
		exit(-1);
	}*/



	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:39:56 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	int cnt{};
	for (int i = 0; i < 1'000; ++i) {
		std::print(out, "{:8} ***", uid(dre));
		if (not ++cnt % 10)
			out << '\n';
	}
	std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ"<<'\n';
		exit(-1);
	}



	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:40:13 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	int cnt{};
	for (int i = 0; i < 1'000; ++i) {
		std::print(out, "{:8} ***", uid(dre));
		if (not(++cnt % 10))
			out << '\n';
	}
	std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ"<<'\n';
		exit(-1);
	}



	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:52:06 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num;
	int maxValue = std::numeric_limits<int>::min();
	size_t cnt { };
	while (in >> num) {
		++cnt;
		if (num > maxValue)
			maxValue = num;
	}
	
	std::cout << "읽은 개수 - " << cnt << '\n';
	std::cout << "최댓값 - " << maxValue << '\n';
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:52:17 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num;
	int maxValue = std::numeric_limits<int>::min();
	size_t cnt { };
	while (in >> num) {
		++cnt;
		if (num > maxValue)
			maxValue = num;
	}
	
	std::cout << "읽은 개수 - " << cnt << '\n';
	std::cout << "최댓값 - " << maxValue << '\n';
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:52:20 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num;
	int maxValue = std::numeric_limits<int>::min();
	size_t cnt { };
	while (in >> num) {
		++cnt;
		if (num > maxValue)
			maxValue = num;
	}
	
	std::cout << "읽은 개수 - " << cnt << '\n';
	std::cout << "최댓값 - " << maxValue << '\n';
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:52:47 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num;
	int maxValue = std::numeric_limits<int>::min();
	size_t cnt { };
	while (in >> num) {
		++cnt;
		if (num > maxValue)
			maxValue = num;
	}
	
	std::cout << "읽은 개수 - " << cnt << '\n';
	std::cout << "최댓값 - " << maxValue << '\n';
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:58:35 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::cout << "최댓값 - " << *std::max_element(std::istream_iterator<int>{in}, {}) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:58:41 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::cout << "최댓값 - " << *std::max_element(std::istream_iterator<int>{in}, {}) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:59:18 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::cout << "최댓값 - " << *std::max_element(std::istream_iterator<int>{in}, {}) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:59:57 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::cout << "최댓값 - " << *std::max_element(std::istream_iterator<int>{in}, {}) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:00:34 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num;
	int maxValue = std::numeric_limits<int>::min();
	size_t cnt { };
	while (in >> num) {
		++cnt;
		if (num > maxValue)
			maxValue = num;
	}
	
	std::cout << "읽은 개수 - " << cnt << '\n';
	std::cout << "최댓값 - " << maxValue << '\n';
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:04:01 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int i{};
	while (in >> arr[i]) {
		++i;
	}

	std::print("{:8}", arr);
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:05:35 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int i{};
	while (in >> arr[i]) {
		std::cout << "!";
		++i;
	}
	std::print("{:8}", arr);
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:06:26 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int i{};
	while (in >> arr[i]) {
		++i;
	}
	std::print("{:8}", arr);
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:07:10 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int i{};
	while (in >> arr[i]) {
		++i;
	}
	std::print("{:8}", arr);
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:09:09 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num;
	
	for (int i = 0; i < num; ++i) {
		in >> num;
		arr[i] = num;
	}

	std::print("{:8}", arr);
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:10:56 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:22:31 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:22:51 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:27:43 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
		std::print("{:2}", i);
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:28:23 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		std::print("{:8}", num);
		arr[i] = num;
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:33:23 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::random_device rd{};
	std::cout << "이 값은 추척 불가능" << std::endl;
	
	for (int i = 0; i < 100; ++i)
		std::cout << rd() << "\t";

	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:35:03 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	int cnt{};
	for (int i = 0; i < 1'000; ++i) {
		std::print(out, "{:8} ***", uid(dre));
		if (not(++cnt % 10))
			out << '\n';
	}
	std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ" << '\n';
		exit(-1);
	}



	save("main.cpp");

	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:35:03 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	int cnt{};
	for (int i = 0; i < 1'000; ++i) {
		std::print(out, "{:8} ***", uid(dre));
		if (not(++cnt % 10))
			out << '\n';
	}
	std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ" << '\n';
		exit(-1);
	}



	save("main.cpp");

	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:36:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	
	std::ofstream out("int 1000개.txt");			// RAII

	int cnt{};
	for (int i = 0; i < 1'000; ++i) {
		std::print(out, "{:8}", uid(dre));
		if (not(++cnt % 10))
			out << '\n';
	}
	std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ" << '\n';
		exit(-1);
	}


	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:36:52 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{

	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:45:27 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <bitset>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

int main()
{
	int num{ 0x01'02'03'04 };

	std::cout << "16진수로 - " << std::hex << num << '\n';
	std::cout << "10진수로 - " << num << '\n';

	std::bitset<32> binary = num ;

	std::cout << "2진수 - " << binary << '\n';
		save("main.cpp"); 
}

=================================================
저장한 시간: 2025-03-18 오후 1:45:44 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <bitset>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

int main()
{
	int num{ 0x01'02'03'04 };

	std::cout << "16진수로 - " << std::hex << num << '\n';
	std::cout << "10진수로 - " << num << '\n';

	std::bitset<32> binary = num ;

	std::cout << " 2진수 - " << binary << '\n';
		save("main.cpp"); 
}

=================================================
저장한 시간: 2025-03-18 오후 1:46:01 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <bitset>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

int main()
{
	int num{ 0x01'02'03'04 };

	std::cout << "16진수로 - " << std::hex << num << '\n';
	std::cout << "10진수로 - " << num << '\n';

	std::bitset<32> binary = num ;

	std::cout << " 2진수로 - " << binary << '\n';
		save("main.cpp"); 
}

=================================================
저장한 시간: 2025-03-18 오후 1:47:14 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <bitset>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

int main()
{
	int num{ 0x01'02'03'04 };

	std::bitset<32> binary = num;

	std::cout << " 2진수로 - " << binary << '\n';
	std::cout << "10진수로 - " << num << '\n';
	std::cout << "16진수로 - " << std::hex << num << '\n';

	
		save("main.cpp"); 
}

=================================================
저장한 시간: 2025-03-18 오후 1:47:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <bitset>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

int main()
{
	int num{ 0x01'02'03'04 };

	std::bitset<32> binary = num;

	std::cout << " 2진수로 - " << binary << '\n';
	std::cout << "10진수로 - " << num << '\n';
	std::cout << "16진수로 - " << std::hex << num << '\n';

	
		save("main.cpp"); 
}

=================================================
저장한 시간: 2025-03-18 오후 2:17:52 화요일
=================================================

=================================================
저장한 시간: 2025-03-18 오후 2:35:55 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// 파일을 "int 10만개를 바이너리모드 write함수로 기록"에 10만개의 랜덤 int 값을 기록하자.
// 이 int값은 메모리 크기 그대로 기록한다.
// 파일을 binary mode로 열자.

std::default_random_engine dre;


int main()
{
	std::ofstream out{ "int 10만개를 바이너리모드 write함수로 기록", std::ios::binary };
	
	std::uniform_int_distribution uid{ std::numeric_limits<int>::min(), std::numeric_limits<int>::max() };

	int num;
	for (int i = 0; i < 10'0000; ++i) {
		num = uid(dre);
		out.write( (char*) & num, sizeof(int));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:49:03 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	
	std::array<int, 100000> a;

	int i{};
	while (in >> a[i]) {
		i++;
	}

	std::cout << *std::min_element(a.begin(), a.end());

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:49:13 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	
	std::array<int, 100000> a;

	int i{};
	while (in >> a[i]) {
		i++;
	}

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:51:07 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록" };
	
	std::array<int, 100000> a;

	int i{};
	while (in >> a[i]) {
		i++;
	}

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:51:14 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	
	std::array<int, 100000> a;

	int i{};
	while (in >> a[i]) {
		i++;
	}

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:51:56 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	int i{};
	while (in >> a[i]) {
		i++;
	}

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:58:00 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:58:41 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	std::cout << "최솟값 - " << * std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:59:26 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록" };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	std::cout << "최솟값 - " << * std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:59:34 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	std::cout << "최솟값 - " << * std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:59:49 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록" };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	std::cout << "최솟값 - " << * std::min_element(a.begin(), a.end()) << '\n';
	// -2147431498

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 3:02:05 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << "최솟값 - " << * std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 3:02:57 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << "최솟값 - " << * std::min_element(a.begin(), a.end()) << '\n';
	// -2147431498

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 3:37:29 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary mode로 열어 write 함수로 int 10만개를 기록한
// 파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
// 읽어서 메모리에 모두 저장하라.
// 메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
// 출력된 값을 답지에도 적어라.

int main()
{
	std::ifstream in{ "int 10만개를 바이너리모드 write함수로 기록", std::ios::binary };

	if (not in) return 20250320;

	std::array<int, 10'0000> a;

	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';
	std::cout << *std::max_element(a.begin(), a.end()) << '\n';



	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 3:40:15 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary mode로 열어 write 함수로 int 10만개를 기록한
// 파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
// 읽어서 메모리에 모두 저장하라.
// 메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
// 출력된 값을 답지에도 적어라.

int main()
{
	std::ifstream in{ "int 10만개를 바이너리모드 write함수로 기록", std::ios::binary };

	if (not in) return 20250320;

	std::array<int, 10'0000> a;

	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';
	std::cout << *std::max_element(a.begin(), a.end()) << '\n';



	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 3:49:06 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary mode로 열어 write 함수로 int 10만개를 기록한
// 파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
// 읽어서 메모리에 모두 저장하라.
// 메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
// 출력된 값을 답지에도 적어라.
// constexpr란?

int main()
{
	std::ifstream in{ "int 10만개를 바이너리모드 write함수로 기록", std::ios::binary };

	if (not in) return 20250320;

	std::array<int, 10'0000> a;
	in.read( (char*)a.data(), sizeof(int) * a.size());

	auto p = std::minmax_element(a.begin(), a.end());
	std::cout << *p.first << '\n';
	std::cout << *p.second << '\n';

	//-2147431498
	//2147393736


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 3:51:37 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary mode로 열어 write 함수로 int 10만개를 기록한
// 파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
// 읽어서 메모리에 모두 저장하라.
// 메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
// 출력된 값을 답지에도 적어라.
// constexpr란?

int main()
{
	std::ifstream in{ "int 10만개를 바이너리모드 write함수로 기록", std::ios::binary };

	if (not in) return 20250320;

	std::array<int, 10'0000> a;
	in.read( (char*)a.data(), sizeof(int) * a.size());

	auto [minAddress, maxAddress] = std::minmax_element(a.begin(), a.end());
	std::cout << *minAddress << '\n';
	std::cout << *maxAddress << '\n';

	//-2147431498
	//2147393736


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:13:58 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - { }", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	Dog dog;
	
	//dog.show();


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:14:42 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		//std::println("[{:7}] - { }", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	Dog dog;
	
	dog.show();


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:15:15 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - ", id);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	Dog dog;
	
	dog.show();


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:15:41 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - ", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	Dog dog;
	
	dog.show();


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:15:59 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - {:}", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	Dog dog;
	
	dog.show();


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:16:59 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - {}", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	Dog dog;
	
	dog.show();


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:18:25 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - {}", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:21:35 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - {}", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	std::ofstream out{ "Dog 10만마리", std::ios::binary };

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out.write((char*)&dog, sizeof(dog));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:31:58 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	//std::array<Dog, 10'0000> arr;

	//in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	//arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:32:46 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

std::array<Dog, 10'0000> arr;
int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:32:57 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

std::array<Dog, 10'0000> arr;
int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:33:36 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

std::array<Dog, 1'0000> arr;
int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:34:27 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	std::array<Dog, 1'0000> arr;

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:34:48 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	std::array<Dog, 1'0000> arr;

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:35:07 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	std::array<Dog, 10> arr;

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:35:38 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	std::array<Dog, 1'0000> arr;

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:40:23 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };

	if (not in)
		return -1;

	Dog dog;

	int count{};
	while (in.read((char*)&dog, sizeof(Dog))) {
		++count;
	}

	std::cout << "읽은 객체 수 - " << count << '\n';
	/*std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	std::array<Dog, 10'0000> arr;

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();*/

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:48:10 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global


	friend std::ostream& operator<< (std::ostream& os, const Dog& dog) {
		return os << dog.name << " - " << dog.id << '\n';
	}
};

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };

	if (not in)
		return -1;

	Dog dog;

	int count{};
	
	in.read((char*)dogs.data(), dogs.size() * sizeof(Dog));
	
	std::cout << dogs[0] << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:48:41 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global


	friend std::ostream& operator<< (std::ostream& os, const Dog& dog) {
		return os << dog.name << " - " << dog.id << '\n';
	}
};

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };

	if (not in)
		return -1;

	Dog dog;

	int count{};
	
	in.read((char*)dogs.data(), dogs.size() * sizeof(Dog));
	
	std::cout << dogs.back() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:54:16 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// 

class Dog {
public:
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global


	friend std::ostream& operator<< (std::ostream& os, const Dog& dog) {
		return os << dog.name << " - " << dog.id;
	}

	friend void operator>> (std::istream& is, Dog& dog) {
		is.read((char*)&dog, sizeof(Dog));
	}
};

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	if (not in)
		return -1;

	// [문제] 다음 코드가 수정없이 실행되도록 필요한 코드를 class Dog에 추가하라.
	for (Dog& dog : dogs) {
		in >> dog;
		std::cout << dog << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 5:03:02 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.

class Dog {
public:
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global


	friend std::ostream& operator<< (std::ostream& os, const Dog& dog) {
		return os << dog.name << " - " << dog.id;
	}

	friend std::istream& operator>> (std::istream& is, Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	if (not in)
		return -1;

	// [문제] 다음 코드가 수정없이 실행되도록 필요한 코드를 class Dog에 추가하라.
	for (Dog& dog : dogs) {
		in >> dog;						// operator>>(in, dog)
		std::cout << dog << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:17:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10];

	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	delete[] p;
}

int main()
{
	for (int i = 0; i < 10; ++i) {
		f();
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:18:06 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10];
	std::cout << p << '\n';
	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	delete[] p;
}

int main()
{
	for (int i = 0; i < 10; ++i) {
		f();
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:19:06 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10] {};
	std::cout << p << '\n';
	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	delete[] p;
}

int main()
{
	for (int i = 0; i < 10; ++i) {
		f();
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:24:48 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10] {};
	std::cout << p << '\n';
	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	throw 15571557;

	delete[] p;
}

int main()
{
	try {
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:25:41 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10] {};
	std::cout << p << '\n';
	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	delete[] p;

	// 시간이 얼추 흐른 후

	delete[] p;
}

int main()
{
	
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:26:12 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10] {};
	std::cout << p << '\n';
	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	delete[] p;

	// 시간이 얼추 흐른 후

	delete[] p;
}

int main()
{
	
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:26:32 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10] {};
	std::cout << p << '\n';
	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	delete[] p;

	// 시간이 얼추 흐른 후

	delete[] p;
}

int main()
{
	
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:28:18 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};


void f()
{
	Dog* p = new Dog;

	delete p;
}

int main()
{
	f();
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:29:42 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};


void f()
{
	Dog* p = new Dog;

	throw 1;

	delete p;
}

int main()
{
	try {
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:39:16 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	smartP p{ new Dog };

	throw 1;
}

int main()
{
	try {
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:41:12 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	std::unique_ptr<Dog> { new Dog };

	throw 1;
}

int main()
{
	try {
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:41:28 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	std::unique_ptr<Dog> { new Dog };

	throw 1;
}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:41:56 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	std::unique_ptr<Dog> asdf { new Dog };

	throw 1;
}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:42:04 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	std::unique_ptr<Dog> asdf { new Dog };

}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:42:39 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	std::unique_ptr<Dog> asdf { new Dog };

	std::cout << "이 줄이 출력될 수 없다" << '\n';
}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:44:09 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	std::unique_ptr<Dog> asdf = std::make_unique<Dog>();

	std::cout << "이 줄이 출력될 수 없다" << '\n';
}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:45:12 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	int num{ 5 };
	std::unique_ptr<Dog[]> asdf = std::make_unique<Dog[]>(num);

	std::cout << "이 줄이 출력될 수 없다" << '\n';
}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:45:22 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	int num{ -1 };
	std::unique_ptr<Dog[]> asdf = std::make_unique<Dog[]>(num);

	std::cout << "이 줄이 출력될 수 없다" << '\n';
}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 3:02:33 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <memory>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
// [문제] "main.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "main upper.cpp"에 저장하시오
//------------------------------------------------------------------



int main()
{
	std::ifstream in{ "main.cpp" };
	
	if (not in)
		return -1557;

	std::ofstream out{ "main upper.cpp" };
	
	char c;
	while (in >> c) {
		if (islower(c))
			c = toupper(c);
		out << c;
	}


	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 3:03:44 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <memory>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
// [문제] "main.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "main upper.cpp"에 저장하시오
//------------------------------------------------------------------



int main()
{
	std::ifstream in{ "main.cpp" };
	
	if (not in)
		return -1557;

	std::ofstream out{ "main upper.cpp" };
	
	char c;
	in >> std::noskipws;
	while (in >> c) {
		if (islower(c))
			c = toupper(c);
		out << c;
	}


	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 3:04:07 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <memory>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
// [문제] "main.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "main upper.cpp"에 저장하시오
//------------------------------------------------------------------



int main()
{
	std::ifstream in{ "main.cpp" };
	
	if (not in)
		return -1557;

	std::ofstream out{ "main upper.cpp" };
	
	char c;
	in >> std::noskipws;
	while (in >> c) {
		c = toupper(c);
		out << c;
	}


	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 3:09:22 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
// [문제] "main.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "main upper.cpp"에 저장하시오
//------------------------------------------------------------------



int main()
{
	std::ifstream in{ "main.cpp" };
	if (not in)
		return -1557;

	std::ofstream out{ "main upper.cpp" };
	
	std::transform(std::istreambuf_iterator<char>(in), {},
		std::ostreambuf_iterator<char>(out),
		[](char c) { return toupper(c); });
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 3:48:22 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	for (int i = 0; i < 1000;++i) {
		std::print("{:8}", (*upArray)[i]);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 3:54:05 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	for (int num : *upArray | std::ranges::views::take(100)) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 3:54:56 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	for (int num : *upArray | std::ranges::views::take(5)
							| std::ranges::views::take(1) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 3:55:14 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	for (int num : *upArray | std::ranges::views::take(5)
							| std::ranges::views::take(1) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 3:55:28 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	for (int num : *upArray | std::ranges::views::take(5) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:17:05 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

// 바꿔야 하면 1
// // 이미 정렬 상태이면 -1
// 둘이 정렬 기준상 동일한 값이면 0
int ascendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// qsort로 오름차순 정렬
	std::qsort(upArray->data(), upArray->size(), sizeof(std::array<int, 1'000'000>::value_type), ascendingOrder);


	// 앞에서 부터 1000개를 화면 출력

	for (int num : *upArray | std::ranges::views::take(1000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:17:49 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

// 바꿔야 하면 1
// // 이미 정렬 상태이면 -1
// 둘이 정렬 기준상 동일한 값이면 0
int ascendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// qsort로 오름차순 정렬
	std::qsort(upArray->data(), upArray->size(), sizeof(std::array<int, 1'000'000>::value_type), ascendingOrder);


	// 앞에서 부터 1000개를 화면 출력

	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:19:44 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

// 바꿔야 하면 1
// // 이미 정렬 상태이면 -1
// 둘이 정렬 기준상 동일한 값이면 0
int ascendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int descendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p > *q)
		return -1;
	else if (*p < *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// qsort로 내림차순 정렬
	std::qsort(upArray->data(), upArray->size(), sizeof(std::array<int, 1'000'000>::value_type), descendingOrder);


	// 앞에서 부터 1000개를 화면 출력

	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:21:08 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

// 바꿔야 하면 1
// // 이미 정렬 상태이면 -1
// 둘이 정렬 기준상 동일한 값이면 0
int ascendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int descendingOrder(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// qsort로 내림차순 정렬
	std::qsort(upArray->data(), upArray->size(), sizeof(std::array<int, 1'000'000>::value_type), descendingOrder);


	// 앞에서 부터 1000개를 화면 출력

	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:21:19 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

// 바꿔야 하면 1
// // 이미 정렬 상태이면 -1
// 둘이 정렬 기준상 동일한 값이면 0
int ascendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int descendingOrder(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// qsort로 내림차순 정렬
	std::qsort(upArray->data(), upArray->size(), sizeof(std::array<int, 1'000'000>::value_type), descendingOrder);


	// 앞에서 부터 1000개를 화면 출력

	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:27:24 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

// 바꿔야 하면 1
// // 이미 정렬 상태이면 -1
// 둘이 정렬 기준상 동일한 값이면 0
int ascendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int descendingOrder(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	int (* orderStandard)(const void*, const void*) = ascendingOrder;

	std::qsort(upArray->data(), upArray->size(), sizeof(int), orderStandard);


	// 앞에서 부터 1000개를 화면 출력

	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:46:38 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;


int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬
	std::sort(upArray->begin(), upArray->end());


	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:48:58 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;


int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬
	std::sort(upArray->rbegin(), upArray->rend());


	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:54:40 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <


	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:57:19 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:57:49 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:58:23 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:58:48 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:58:53 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:58:58 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:59:07 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:59:12 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:00:09 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';
	std::cout << "경과시간(ms) - " << (e - b) / 100 << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:00:47 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';
	std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:01:12 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';
	std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:04:17 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };
	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	{
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(), ascendingOrder);			// 디폴트 정렬 operator <
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	{	// 내림차순으로 정렬
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(),[](const int a, const int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:04:55 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };
	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	{
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(), ascendingOrder);			// 디폴트 정렬 operator <
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	{	// 내림차순으로 정렬
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(),[](const int a, const int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:05:24 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };
	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	{
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(), [](const int a, const int b) {
			return a < b;
			});			// 디폴트 정렬 operator <
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	{	// 내림차순으로 정렬
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(),[](const int a, const int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:07:00 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };
	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	{
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(), ascendingOrder);			// 디폴트 정렬 operator <
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	{	// 내림차순으로 정렬
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(),[](const int a, const int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:07:13 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };
	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	{
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(), ascendingOrder);			// 디폴트 정렬 operator <
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	{	// 내림차순으로 정렬
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(),[](const int a, const int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:10:11 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };
	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	{
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(), ascendingOrder);			// 디폴트 정렬 operator <
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	{	// 내림차순으로 정렬
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort<std::array<int,10'000'000>::iterator>(upArray->begin(), upArray->end(),[](const int a, const int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:34:59 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?

	[]() {
		std::cout << "ㅎㅇ" << std::endl;

		}();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:36:26 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?

	typeid([]() {
		std::cout << "ㅎㅇ" << std::endl;

		});

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:37:33 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?
	std::cout <<
	typeid([]() {
		std::cout << "ㅎㅇ" << std::endl;

		}).name() << '\n';;

	save("main.cpp");
	
}

=================================================
저장한 시간: 2025-04-01 오후 1:39:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?
	std::cout << "람다 1의 정체 - " <<
	typeid([]() {
		std::cout << "ㅎㅇ" << std::endl;

		}).name()
			<< '\n';

	std::cout << "람다 2의 정체 - " <<
		typeid([]() {
		std::cout << "ㅎㅇ" << std::endl;
			}).name()
			<< '\n';
	save("main.cpp");
	
}

=================================================
저장한 시간: 2025-04-01 오후 1:40:21 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?
	std::cout << "람다 1의 정체 - " <<
		typeid([]() {
			std::cout << "ㅎㅇ" << std::endl;
		}).name()
		<< '\n';

	save("main.cpp");
	
}

=================================================
저장한 시간: 2025-04-01 오후 1:43:34 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?
	
	auto asdf = save;
	std::cout << asdf << '\n';
	save("main.cpp");
	
}

=================================================
저장한 시간: 2025-04-01 오후 1:44:04 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?
	
	int* asdf = (int*)save;
	std::cout << asdf << '\n';
	save("main.cpp");
	
}

=================================================
저장한 시간: 2025-04-01 오후 1:49:54 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class DOG {
public:
	void operator()() {
		std::cout << "왜" << '\n';
	}
};

int main()
{
	DOG dog;
	
	dog();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:51:00 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class DOG {
public:
	bool operator()(int a, int b) {
		return a < b;
	}
};

int main()
{
	DOG dog;
	
	dog(1,2);

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:51:16 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class DOG {
public:
	bool operator()(int a, int b) {
		return a < b;
	}
};

int main()
{
	DOG dog;
	
	std::cout<<dog(1,2)<<'\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:51:48 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class DOG {
public:
	bool operator()(int a, int b) {
		return a < b;
	}
};

int main()
{
	DOG dog;
	
	std::cout << typeid(dog).name() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:52:05 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?



int main()
{
	class DOG {
	public:
		bool operator()(int a, int b) {
			return a < b;
		}
	};

	DOG dog;
	
	std::cout << typeid(dog).name() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:52:49 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?



int main()
{
	std::cout << typeid(
	[]() {

		}).name() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:53:09 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?



int main()
{
	std::cout << typeid(
	[]() {

		}).name() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:09:45 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

	class Dog {
	public:
		bool operator()(const int& a, const int& b) const {
			return a > b;
		}
	};

	std::sort(a.begin(), a.end(), Dog {});

	for (const int& num : a) {
		std::cout << num;
	}
	std::cout << '\n';			// 10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:13:28 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

	auto Dog = [](int a, int b)->bool {
		return a > b;
		};

	std::sort(a.begin(), a.end(), Dog);

	for (const int& num : a) {
		std::cout << num;
	}
	std::cout << '\n';			// 10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:13:39 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

	auto Dog = [](int a, int b)->bool {
		return a > b;
		};

	std::sort(a.begin(), a.end(), Dog);

	for (const int& num : a) {
		std::cout << num << ' ';
	}
	std::cout << '\n';			// 10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:15:26 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

	class Dog {
	public:
		bool operator()(int a, int b) const {
			return a > b;
		}
	};

	std::sort(a.begin(), a.end(), Dog{});

	for (const int& num : a) {
		std::cout << num << ' ';
	}
	std::cout << '\n';			// 10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:27:14 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
// 5. 멤버함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	auto p = [](int a, int b) {return a > b; };

	std::cout << std::boolalpha << p(3, 4) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:28:58 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입		--------> 모든 것을 대표하는 function
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
// 5. 멤버함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <functional>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	auto p = [](int a, int b) {return a > b; };


	std::function<bool(int,int)> DescendingDrder = p;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:29:17 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입		--------> 모든 것을 대표하는 function
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
// 5. 멤버함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <functional>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	auto p = [](int a, int b) {return a > b; };


	std::function<bool(int,int)> DescendingDrder = p;

	std::cout << DescendingDrder(3, 4) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:38:58 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const{
		std::print("{:12} - {}\n", id, name);
	}
private:
	std::string name;
	int id;
};

int main()
{
	std::array<Dog, 10> dogs;
	for (const Dog& dog: dogs) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:39:05 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const{
		std::print("{:12} - {}\n", id, name);
	}
private:
	std::string name;
	int id;
};

int main()
{
	std::array<Dog, 10> dogs;
	for (const Dog& dog: dogs) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:39:19 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
			name = "123";
		}
		id = uidId(dre);
	}

	void show() const{
		std::print("{:12} - {}\n", id, name);
	}
private:
	std::string name;
	int id;
};

int main()
{
	std::array<Dog, 10> dogs;
	for (const Dog& dog: dogs) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:45:08 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <array>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const{
		std::print("{:12} - {}\n", id, name);

	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}
private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// std::ofstream out("Dog 십만마리");
// 
// Dog dog;
// out << dog;
// ostream& operator<<( ostream& os, const Dog& dog ) {
//		return os << dog.id << " " << dog.name << " ";
// }

int main()
{
	std::ofstream out("Dog 십만마리");

	for (int i = 0; i < 10; ++i) {
		Dog dog;
		out << dog;
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:45:19 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <array>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const{
		std::print("{:12} - {}\n", id, name);

	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}
private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// std::ofstream out("Dog 십만마리");
// 
// Dog dog;
// out << dog;
// ostream& operator<<( ostream& os, const Dog& dog ) {
//		return os << dog.id << " " << dog.name << " ";
// }

int main()
{
	std::ofstream out("Dog 십만마리");

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:46:04 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <array>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const{
		std::print("{:12} - {}\n", id, name);

	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}
private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// std::ofstream out("Dog 십만마리");
// 
// Dog dog;
// out << dog;
// ostream& operator<<( ostream& os, const Dog& dog ) {
//		return os << dog.id << " " << dog.name << " ";
// }

int main()
{
	std::ofstream out("Dog 십만마리");

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << std::noskipws;
		out << dog;
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 3:08:48 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <memory>
#include <array>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}
private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000 > dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	for (int i = 0; i < 10'0000; ++i) {
		int id;
		std::string name;
		in >> id >> name;
		dogs[i].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:21:49 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <memory>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {

		return id;
	}
private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000 > dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	for (int i = 0; i < 10'0000; ++i) {
		int id;
		std::string name;
		in >> id >> name;
		dogs[i].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getId() < b.getId();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:22:41 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <memory>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {
		return id;
	}

	std::string getName() {
		return name;
	}

private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000 > dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	for (int i = 0; i < 10'0000; ++i) {
		int id;
		std::string name;
		in >> id >> name;
		dogs[i].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getName().length() < b.getName().length();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:23:21 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <memory>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {
		return id;
	}

	std::string getName() {
		return name;
	}

private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000 > dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> id >> name;
		dogs[i].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getName().length() < b.getName().length();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:33:25 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {
		return id;
	}

	std::string getName() {
		return name;
	}

private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> id >> name;
		dogs[i].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getName().length() < b.getName().length();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:36:19 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {
		return id;
	}

	std::string getName() {
		return name;
	}

	

private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	int i{};
	while(in >> id >> name) {
		dogs[i++].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getName().length() < b.getName().length();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:39:10 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {
		return id;
	}

	std::string getName() {
		return name;
	}

	

private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	int count{};
	while(in >> id >> name) {
		std::println("[{:7}] : {:12} - {}", count, id, name);
		dogs[count++].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getName().length() < b.getName().length();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:39:33 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {
		return id;
	}

	std::string getName() {
		return name;
	}

	

private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	int count{};
	while(in >> id >> name) {
		std::println("{:7} : {:12} - {}", count, id, name);
		dogs[count++].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getName().length() < b.getName().length();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:47:38 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:9} - {}", id, name);
	}

	size_t nameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.nameLength() < b.nameLength();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:47:52 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:9} - {}", id, name);
	}

	size_t nameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.nameLength() < b.nameLength();
		});

	for (int i = 0; i < 1000; ++i) {
		dogs.back().show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:48:06 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:9} - {}", id, name);
	}

	size_t nameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.nameLength() < b.nameLength();
		});

	for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:55:54 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:9} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNameLength() < b.getNameLength();
		});

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:56:20 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNameLength() < b.getNameLength();
		});

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:57:51 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNameLength() < b.getNameLength();
		});

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs | std::views::take(1000)) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:59:04 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNameLength() < b.getNameLength();
		});

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs | std::views::reverse | std::views::take(1000)) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:03:40 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}
	
	friend bool operator<(Dog a, Dog b) {
		return a.getNameLength() < b.getNameLength();
	}


private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end());

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs | std::views::reverse | std::views::take(1000)) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:04:53 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}
	
	bool operator<(const Dog& rhs) {
		return getNameLength() < rhs.getNameLength();
	}


private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end());

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs | std::views::reverse | std::views::take(1000)) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:05:35 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}
	
	bool operator<(const Dog& rhs) const {
		return name.length() < rhs.name.length();
	}


private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end());

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs | std::views::reverse | std::views::take(1000)) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:05:48 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}
	
	bool operator<(const Dog& rhs) const {
		return name.length() < rhs.name.length();
	}


private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end());

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs | std::views::take(1000)) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:37:57 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {

};
	
int main()
{
	std::string s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:44:55 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}
	STRING(const char* in) {
		strSize = sizeof(in);
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}
	~STRING() {
		delete[] str;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, STRING s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:45:24 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}
	STRING(const char* in) {
		strSize = sizeof(in);
		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}
	~STRING() {
		delete[] str;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, STRING s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:50:34 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}
	STRING(const char* in) {
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}
	~STRING() {
		delete[] str;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, STRING s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:50:49 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}
	STRING(const char* in) {
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}
	~STRING() {
		delete[] str;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, STRING s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수
	std::cout << 1557;
	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:51:13 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}
	STRING(const char* in) {
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}
	~STRING() {
		std::cout << 1557;
		delete[] str;
		std::cout << 1557;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, STRING s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:51:28 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}
	STRING(const char* in) {
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}

	~STRING() {
		std::cout << 1557;
		delete[] str;
		std::cout << 1557;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, STRING s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:52:26 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}

	STRING(const char* in) {
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}

	~STRING() {
		std::cout << 1557;
		delete[] str;
		std::cout << 1557;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, const STRING& s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:52:41 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}

	STRING(const char* in) {
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}

	~STRING() {
		std::cout << 1557;
		delete[] str;
		std::cout << 1557;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, const STRING& s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:53:25 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}

	STRING(const char* in) {			// [] -> *로 collapsing
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}

	~STRING() {
		delete[] str;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, const STRING& s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:53:40 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}

	STRING(const char* in) {			// [] -> *로 collapsing
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}

	~STRING() {
		delete[] str;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, const STRING& s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 5:07:31 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING(const char* in) : length{ strlen(in) } {			// [] -> *로 collapsing
		pStr.reset();
		pStr = std::make_unique<char[]>(length);

		memcpy(pStr.get(), in, length);							// DMA
	}

	size_t size() const {
		return length;
	}

	

private:
	size_t length;
	std::unique_ptr<char[]> pStr;


	friend std::ostream& operator<< ( std::ostream & os, const STRING& str ) {
		os << str;
		return os;
	}
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 5:07:50 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING(const char* in) : length{ strlen(in) } {			// [] -> *로 collapsing
		pStr.reset();
		pStr = std::make_unique<char[]>(length);

		memcpy(pStr.get(), in, length);							// DMA
	}

	size_t size() const {
		return length;
	}

	

private:
	size_t length;
	std::unique_ptr<char[]> pStr;


	friend std::ostream& operator<< ( std::ostream & os, const STRING& str ) {
		os << str.pStr;
		return os;
	}
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 5:10:45 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING(const char* in) : length{ strlen(in) } {			// [] -> *로 collapsing
		pStr.reset();
		pStr = std::make_unique<char[]>(length);

		memcpy(pStr.get(), in, length);							// DMA
	}

	size_t size() const {
		return length;
	}

	

private:
	size_t length;
	std::unique_ptr<char[]> pStr;


	friend std::ostream& operator<< ( std::ostream & os, const STRING& str ) {
		for (int i = 0; i < str.length; ++i) {
			os << str.pStr[i];
		}
		return os;
	}
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 5:11:10 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING(const char* in) : length{ strlen(in) } {			// [] -> *로 collapsing
		pStr.reset();
		pStr = std::make_unique<char[]>(length);

		memcpy(pStr.get(), in, length);							// DMA
	}

	size_t size() const {
		return length;
	}

	

private:
	size_t length;
	std::unique_ptr<char[]> pStr;


	friend std::ostream& operator<< ( std::ostream & os, const STRING& str ) {
		for (int i = 0; i < str.length; ++i) {
			os << str.pStr[i];
		}
		return os;
	}
};
	
int main()
{
	STRING s{ "st" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 1:38:37 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 1:49:43 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 1:49:54 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 1:50:16 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 1:54:59 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	std::cout << "1" << '\n';
	STRING t;
	std::cout << "2" << '\n';
	t = s;
	std::cout << "3" << '\n';
	STRING u = s;
	std::cout << "4" << '\n';

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:19:31 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:31:08 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:32:15 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:32:36 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:33:00 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:35:29 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:36:23 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:37:35 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:39:09 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:39:58 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:40:40 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:42:43 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:43:15 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:49:35 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:50:05 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool 관찰;					// 관찰하려면 true로 설정

int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:51:13 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool 관찰;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	STRING t = s;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:52:10 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool 관찰;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	STRING t = s;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:53:33 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool 관찰;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	std::cout << "hi main" << '\n';
	STRING t = s;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:55:05 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool 관찰;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	std::cout << "hi main" << '\n';
	STRING t = s;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:57:23 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	watching = false;
	std::cout << "hi main" << '\n';
	STRING t = s;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:00:41 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라

	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			return rhs.size() < lhs.size();
		});

	for (const STRING& str : a) {
		std::cout << str << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:01:38 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라

	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			std::cout << "비교 : " << rhs << '/' << lhs << '\n';
			return rhs.size() < lhs.size();
		});

	for (const STRING& str : a) {
		std::cout << str << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:05:32 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	watching = false;

	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라

	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			return rhs.size() < lhs.size();
		});

	for (const STRING& str : a) {
		std::cout << str << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:06:46 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	watching = false;

	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라

	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			return rhs.size() < lhs.size();
		});

	
	watching = true;
	for (const STRING& str : a) {
		std::cout << str << '\n';
	}
	watching = false;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:07:09 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	watching = false;

	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라

	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			return rhs.size() < lhs.size();
		});

	
	watching = true;
	for (const auto& str : a) {
		std::cout << str << '\n';
	}
	watching = false;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:08:09 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	watching = false;

	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라
	watching = true;
	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			return rhs.size() < lhs.size();
		});
	watching = false;
	
	
	for (const STRING& str : a) {
		std::cout << str << '\n';
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:10:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	watching = false;

	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라
	watching = true;
	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			return rhs.size() < lhs.size();
		});
	watching = false;
	
	
	for (const STRING& str : a) {
		std::cout << str << '\n';
	}
	

	save("main.cpp");
}