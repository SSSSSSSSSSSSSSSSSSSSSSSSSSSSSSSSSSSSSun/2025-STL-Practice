

=================================================
저장한 시간: 2025-03-11 오후 1:49:20 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// save 파일로 분리 / template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <vector>
//#include <algorithm>
#include <chrono>
void save( std::string_view );


int main()
{

	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 1:54:34 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// save 파일로 분리 / template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"

// [문제] main에서 의도대로 실행되게


int main()
{

	int a{ 1 }, b{ 2 };

	save("main.cpp");
	save("save.h");
	save("save.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 1:54:34 화요일
=================================================

#pragma once
//---------------------------------------------------------------
// save.h								2025년 3월 11일
// 
// --------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

=================================================
저장한 시간: 2025-03-11 오후 1:54:34 화요일
=================================================

//---------------------------------------------------------------
// save.cpp								2025년 3월 11일
// 
// 한 학기 강의를 덧붙여 저장하는 함수이다.
// --------------------------------------------------------------
#include "save.h"

void save(std::string_view fileName)
{
	// fileName을 읽기모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다" << std::endl;
		exit(20250306);
	}

	// 쓰기모드로 저장할 파일을 연다
	std::string nameForSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameForSave , std::ios::app };

	// 저장했다고 화면 출력

	auto size = std::filesystem::file_size(fileName);
	std::cout << nameForSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << "Bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();				// time_point를 얻는다. epoch
	auto utc = std::chrono::system_clock::to_time_t(now);		// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);			// 원 locale을 복구

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::vector<char> v(size);
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 1:59:45 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// save 파일로 분리 / template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] main에서 의도대로 실행되게


template <typename T>
void change(T& a, T& b) {
	T temp = a;
	b = a;
	a = temp;
}

int main()
{

	int a{ 1 }, b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	save("main.cpp");
	save("save.h");
	save("save.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 1:59:45 화요일
=================================================

#pragma once
//---------------------------------------------------------------
// save.h								2025년 3월 11일
// 
// --------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

=================================================
저장한 시간: 2025-03-11 오후 1:59:45 화요일
=================================================

//---------------------------------------------------------------
// save.cpp								2025년 3월 11일
// 
// 한 학기 강의를 덧붙여 저장하는 함수이다.
// --------------------------------------------------------------
#include "save.h"

void save(std::string_view fileName)
{
	// fileName을 읽기모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다" << std::endl;
		exit(20250306);
	}

	// 쓰기모드로 저장할 파일을 연다
	std::string nameForSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameForSave , std::ios::app };

	// 저장했다고 화면 출력

	auto size = std::filesystem::file_size(fileName);
	std::cout << nameForSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << "Bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();				// time_point를 얻는다. epoch
	auto utc = std::chrono::system_clock::to_time_t(now);		// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);			// 원 locale을 복구

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::vector<char> v(size);
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 2:00:02 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// save 파일로 분리 / template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] main에서 의도대로 실행되게


template <typename T>
void change(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}

int main()
{

	int a{ 1 }, b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	save("main.cpp");
	save("save.h");
	save("save.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 2:00:02 화요일
=================================================

#pragma once
//---------------------------------------------------------------
// save.h								2025년 3월 11일
// 
// --------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

=================================================
저장한 시간: 2025-03-11 오후 2:00:02 화요일
=================================================

//---------------------------------------------------------------
// save.cpp								2025년 3월 11일
// 
// 한 학기 강의를 덧붙여 저장하는 함수이다.
// --------------------------------------------------------------
#include "save.h"

void save(std::string_view fileName)
{
	// fileName을 읽기모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다" << std::endl;
		exit(20250306);
	}

	// 쓰기모드로 저장할 파일을 연다
	std::string nameForSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameForSave , std::ios::app };

	// 저장했다고 화면 출력

	auto size = std::filesystem::file_size(fileName);
	std::cout << nameForSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << "Bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();				// time_point를 얻는다. epoch
	auto utc = std::chrono::system_clock::to_time_t(now);		// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);			// 원 locale을 복구

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::vector<char> v(size);
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 2:03:07 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// save 파일로 분리 / template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] main을 수정하지 않고 의도대로 실행되게

void change(int&, int&);

int main()
{

	int a{ 1 }, b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	save("main.cpp");
	save("save.h");
	save("save.cpp");
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

=================================================
저장한 시간: 2025-03-11 오후 2:03:07 화요일
=================================================

#pragma once
//-----------------------------------------------------------------------------
// save.h								2025년 3월 11일
// ----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <chrono>

// [문제] save 함수를 제대로 코딩하라.
void save(std::string_view);

=================================================
저장한 시간: 2025-03-11 오후 2:03:07 화요일
=================================================

//---------------------------------------------------------------
// save.cpp								2025년 3월 11일
// 
// 한 학기 강의를 덧붙여 저장하는 함수이다.
// --------------------------------------------------------------
#include "save.h"

void save(std::string_view fileName)
{
	// fileName을 읽기모드로 연다
	std::ifstream in{ fileName.data() };		// RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다" << std::endl;
		exit(20250306);
	}

	// 쓰기모드로 저장할 파일을 연다
	std::string nameForSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameForSave , std::ios::app };

	// 저장했다고 화면 출력

	auto size = std::filesystem::file_size(fileName);
	std::cout << nameForSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << "Bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();				// time_point를 얻는다. epoch
	auto utc = std::chrono::system_clock::to_time_t(now);		// UTC 시간으로 변경
	auto lt = std::localtime(&utc);							// 지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);			// 원 locale을 복구

	// 읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::vector<char> v(size);
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 2:27:04 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// save 파일로 분리 / template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] main을 수정하지 않고 의도대로 실행되게

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

void change(Dog&, Dog&);
void change(int&, int&);

int main()
{
	{
		Dog a{1}, b{2};
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}


void change(Dog& a, Dog& b) {
	Dog temp{ a };
	a = b;
	b = temp;
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

=================================================
저장한 시간: 2025-03-11 오후 2:33:27 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

void change(Dog&, Dog&);
void change(int&, int&);

int main()
{
	{
		Dog a{1}, b{2};
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}


void change(Dog& a, Dog& b) {
	Dog temp{ a };
	a = b;
	b = temp;
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

=================================================
저장한 시간: 2025-03-11 오후 2:33:43 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

void change(Dog&, Dog&);
void change(int&, int&);

int main()
{
	{
		Dog a{1}, b{2};
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}


void change(Dog& a, Dog& b) {
	Dog temp{ a };
	a = b;
	b = temp;
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

=================================================
저장한 시간: 2025-03-11 오후 2:36:46 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

template <class T>
void change(T&, T&);

int main()
{
	{
		Dog a{1}, b{2};
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}

template <class T>
void change(T& a, T& b) {
	T temp{ a };
	a = b;
	b = temp;
}

=================================================
저장한 시간: 2025-03-11 오후 2:41:14 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

template <class T>
void change(T& a, T& b) {
	T temp{ a };
	a = b;
	b = temp;
}

int main()
{
	std::cout << "Dog의 크기 = " << sizeof(Dog);
	{
		Dog a{1}, b{2};
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 2:53:51 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

template <class T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

template <>
void change(Dog& a, Dog& b)
{
	Dog temp{ a };
	a = b;
	b = temp;
}

template <>
void change(int& a, int& b)
{
	int temp{ a };
	a = b;
	b = temp;
}

int main()
{
	{
		Dog a{1}, b{2};
		change(a, b);
		// 1. change( Dog, Dog );
		// 2. change( Dog&, Dog& );
		// 3. 컴파일러가 template을 이용하여 코드 생성
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 2:55:03 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함

class Dog {
private:
	int integer{ };

public:
	Dog() {};
	Dog(int input) : integer(input) {}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.integer;
	}

};

template <class T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

int main()
{
	{
		Dog a{1}, b{2};
		change(a, b);
		// 1. change( Dog, Dog );
		// 2. change( Dog&, Dog& );
		// 3. 컴파일러가 template을 이용하여 코드 생성
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.

	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;		// 의도 - 2, 1 이 출력되어야 한다.
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 2:55:22 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// template 복습
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// [문제] C++언어에서 change 함수는 몇 번이나 overloading 해야 할까?
// --> C++ 언어의 자료형은 몇 개인가? -> 무한함


int main()
{
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 2:59:43 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// 랜덤 int 1000개를 화면에 출력하라

void printRandomInt() {
	std::random_device rd;
	std::uniform_int_distribution<int> randomNumber(0, 9);
	
	for (int i = 0; i < 1000; i++) {
		std::cout << randomNumber << '\n';
	}
}

int main()
{
	printRandomInt();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 3:00:33 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다.

// 랜덤 int 1000개를 화면에 출력하라

void printRandomInt() {
	std::random_device rd;
	std::uniform_int_distribution<int> uid (0, 9);
	
	for (int i = 0; i < 1000; i++) {
		std::cout << uid(rd) << '\n';
	}
}

int main()
{
	printRandomInt();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 3:06:08 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// 랜덤 int 1000개를 화면에 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{ 0,9999999 };

int main()
{
	for (int i = 0; i < 1000; ++i) {
		std::cout << uid(dre) << " ";
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 3:08:13 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// 랜덤 int 1000개를 화면에 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{ 0,9999999 };

int main()
{
	for (int i = 0; i < 1000; ++i) {
		std::print("{:8}", uid(dre));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 11:20:24 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{ 0,9999999 };

int main()
{
	for (int i = 0; i < 1000; ++i) {
		std::print("{:8}", uid(dre));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-11 오후 11:32:24 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{ 0,9999999 };

int main()
{
	for (int i = 0; i < 1000; ++i) {
		std::print("{:8}", uid(dre));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 3:35:39 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	for (int i = 0; i < 1000; ++i) {
		std::print("{:8}", uid(dre));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 3:38:22 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	for (int i = 0; i < 1000; ++i) {
		std::print("{:8}", uid(dre));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 3:51:56 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };




int main()
{
	// T[N]
	int arr[ 1'000 ];

	for (int i = 0; i < 1000; ++i) {
		arr[i] = uid(dre);
	}

	int maxValue{ std::numeric_limits<int>::min() };

	for (int i = 0; i < 1000; ++i) {
		if (arr[i] > maxValue)
			maxValue = arr[i];
	}

	std::cout << "최댓값 = " << maxValue << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:09:54 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };




int main()
{
	std::array<int, 1000> arr;						// T[N] ---> array<T,N>

	for ( int& num : arr )			// magic number, hard-wired
		num = uid(dre);

	auto 위치 = std::max_element(arr.begin(), arr.end());


	std::cout << "최댓값 = " << *위치 << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:11:10 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 6일 목요일					(1주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 큰 값을 찾아 화면에 출력하라

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };




int main()
{
	std::array<int, 1000> arr;						// T[N] ---> array<T,N>

	for (int& num : arr)			// magic number, hard-wired
		num = uid(dre);

	std::cout << "최댓값 = " << *(std::max_element(arr.begin(), arr.end())) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:26:06 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <array>
#include <algorithm>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::print("(:80)", 20250311);

	/*for (int i = 0; i < 1'000; ++i) {
		std::print("(:8)", uid(dre));
	}*/


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:26:30 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <array>
#include <algorithm>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::print("(:80)", 20250311);

	/*for (int i = 0; i < 1'000; ++i) {
		std::print("(:8)", uid(dre));
	}*/


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:27:06 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::print("(:80)", 20250311);

	/*for (int i = 0; i < 1'000; ++i) {
		std::print("(:8)", uid(dre));
	}*/


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:31:23 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	for (int i = 0; i < 1'000; ++i)
		std::print(out, "{:8}", uid(dre));


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:32:28 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	for (int i = 0; i < 1'000; ++i)
		std::print(out, "{:8}", uid(dre));


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:32:45 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	for (int i = 0; i < 1'000; ++i)
		std::print(out, "{:8}", uid(dre));


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:36:32 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	for (int i = 0; i < 1'000; ++i)
		std::print(out, "{:8}", uid(dre));

	/*std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ"<<'\n';
		exit(-1);
	}*/



	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:37:23 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	for (int i = 0; i < 1'000; ++i)
		std::print(out, "{:8} ***", uid(dre));

	/*std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ"<<'\n';
		exit(-1);
	}*/



	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:39:56 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	int cnt{};
	for (int i = 0; i < 1'000; ++i) {
		std::print(out, "{:8} ***", uid(dre));
		if (not ++cnt % 10)
			out << '\n';
	}
	std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ"<<'\n';
		exit(-1);
	}



	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:40:13 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 랜덤 int 1000개를 파일 "int 1000개.txt"에 텍스트 모드로 저장하라.
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	int cnt{};
	for (int i = 0; i < 1'000; ++i) {
		std::print(out, "{:8} ***", uid(dre));
		if (not(++cnt % 10))
			out << '\n';
	}
	std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ"<<'\n';
		exit(-1);
	}



	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:52:06 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num;
	int maxValue = std::numeric_limits<int>::min();
	size_t cnt { };
	while (in >> num) {
		++cnt;
		if (num > maxValue)
			maxValue = num;
	}
	
	std::cout << "읽은 개수 - " << cnt << '\n';
	std::cout << "최댓값 - " << maxValue << '\n';
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:52:17 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num;
	int maxValue = std::numeric_limits<int>::min();
	size_t cnt { };
	while (in >> num) {
		++cnt;
		if (num > maxValue)
			maxValue = num;
	}
	
	std::cout << "읽은 개수 - " << cnt << '\n';
	std::cout << "최댓값 - " << maxValue << '\n';
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:52:20 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num;
	int maxValue = std::numeric_limits<int>::min();
	size_t cnt { };
	while (in >> num) {
		++cnt;
		if (num > maxValue)
			maxValue = num;
	}
	
	std::cout << "읽은 개수 - " << cnt << '\n';
	std::cout << "최댓값 - " << maxValue << '\n';
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:52:47 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num;
	int maxValue = std::numeric_limits<int>::min();
	size_t cnt { };
	while (in >> num) {
		++cnt;
		if (num > maxValue)
			maxValue = num;
	}
	
	std::cout << "읽은 개수 - " << cnt << '\n';
	std::cout << "최댓값 - " << maxValue << '\n';
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:58:35 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::cout << "최댓값 - " << *std::max_element(std::istream_iterator<int>{in}, {}) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:58:41 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::cout << "최댓값 - " << *std::max_element(std::istream_iterator<int>{in}, {}) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:59:18 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::cout << "최댓값 - " << *std::max_element(std::istream_iterator<int>{in}, {}) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 4:59:57 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::cout << "최댓값 - " << *std::max_element(std::istream_iterator<int>{in}, {}) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:00:34 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.



int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num;
	int maxValue = std::numeric_limits<int>::min();
	size_t cnt { };
	while (in >> num) {
		++cnt;
		if (num > maxValue)
			maxValue = num;
	}
	
	std::cout << "읽은 개수 - " << cnt << '\n';
	std::cout << "최댓값 - " << maxValue << '\n';
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:04:01 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int i{};
	while (in >> arr[i]) {
		++i;
	}

	std::print("{:8}", arr);
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:05:35 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int i{};
	while (in >> arr[i]) {
		std::cout << "!";
		++i;
	}
	std::print("{:8}", arr);
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:06:26 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int i{};
	while (in >> arr[i]) {
		++i;
	}
	std::print("{:8}", arr);
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:07:10 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int i{};
	while (in >> arr[i]) {
		++i;
	}
	std::print("{:8}", arr);
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:09:09 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num;
	
	for (int i = 0; i < num; ++i) {
		in >> num;
		arr[i] = num;
	}

	std::print("{:8}", arr);
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-13 오후 5:10:56 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:22:31 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:22:51 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:27:43 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
		std::print("{:2}", i);
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:28:23 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		std::print("{:8}", num);
		arr[i] = num;
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:33:23 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.


int main()
{
	std::random_device rd{};
	std::cout << "이 값은 추척 불가능" << std::endl;
	
	for (int i = 0; i < 100; ++i)
		std::cout << rd() << "\t";

	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:35:03 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	int cnt{};
	for (int i = 0; i < 1'000; ++i) {
		std::print(out, "{:8} ***", uid(dre));
		if (not(++cnt % 10))
			out << '\n';
	}
	std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ" << '\n';
		exit(-1);
	}



	save("main.cpp");

	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:35:03 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	std::ofstream out("int 1000개.txt");			// RAII

	int cnt{};
	for (int i = 0; i < 1'000; ++i) {
		std::print(out, "{:8} ***", uid(dre));
		if (not(++cnt % 10))
			out << '\n';
	}
	std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ" << '\n';
		exit(-1);
	}



	save("main.cpp");

	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:36:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{
	
	std::ofstream out("int 1000개.txt");			// RAII

	int cnt{};
	for (int i = 0; i < 1'000; ++i) {
		std::print(out, "{:8}", uid(dre));
		if (not(++cnt % 10))
			out << '\n';
	}
	std::ifstream in("int 1000개.txt");
	if (not in) {
		std::cout << "파일 없음 ㅇㅇ" << '\n';
		exit(-1);
	}


	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:36:52 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 13일 목요일					(2주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include <print>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// 
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하라.

std::default_random_engine dre{ std::random_device{}() };
std::uniform_int_distribution uid{ 0,999'9999 };

int main()
{

	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> arr{};
	int num{ arr.size() };
	
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr) {
		std::print("{:8}", num );
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 1:45:27 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <bitset>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

int main()
{
	int num{ 0x01'02'03'04 };

	std::cout << "16진수로 - " << std::hex << num << '\n';
	std::cout << "10진수로 - " << num << '\n';

	std::bitset<32> binary = num ;

	std::cout << "2진수 - " << binary << '\n';
		save("main.cpp"); 
}

=================================================
저장한 시간: 2025-03-18 오후 1:45:44 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <bitset>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

int main()
{
	int num{ 0x01'02'03'04 };

	std::cout << "16진수로 - " << std::hex << num << '\n';
	std::cout << "10진수로 - " << num << '\n';

	std::bitset<32> binary = num ;

	std::cout << " 2진수 - " << binary << '\n';
		save("main.cpp"); 
}

=================================================
저장한 시간: 2025-03-18 오후 1:46:01 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <bitset>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

int main()
{
	int num{ 0x01'02'03'04 };

	std::cout << "16진수로 - " << std::hex << num << '\n';
	std::cout << "10진수로 - " << num << '\n';

	std::bitset<32> binary = num ;

	std::cout << " 2진수로 - " << binary << '\n';
		save("main.cpp"); 
}

=================================================
저장한 시간: 2025-03-18 오후 1:47:14 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <bitset>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

int main()
{
	int num{ 0x01'02'03'04 };

	std::bitset<32> binary = num;

	std::cout << " 2진수로 - " << binary << '\n';
	std::cout << "10진수로 - " << num << '\n';
	std::cout << "16진수로 - " << std::hex << num << '\n';

	
		save("main.cpp"); 
}

=================================================
저장한 시간: 2025-03-18 오후 1:47:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <bitset>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] 지난시간에 int 1000개를 파일에 기록하였다.
// int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

int main()
{
	int num{ 0x01'02'03'04 };

	std::bitset<32> binary = num;

	std::cout << " 2진수로 - " << binary << '\n';
	std::cout << "10진수로 - " << num << '\n';
	std::cout << "16진수로 - " << std::hex << num << '\n';

	
		save("main.cpp"); 
}

=================================================
저장한 시간: 2025-03-18 오후 2:17:52 화요일
=================================================

=================================================
저장한 시간: 2025-03-18 오후 2:35:55 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// 파일을 "int 10만개를 바이너리모드 write함수로 기록"에 10만개의 랜덤 int 값을 기록하자.
// 이 int값은 메모리 크기 그대로 기록한다.
// 파일을 binary mode로 열자.

std::default_random_engine dre;


int main()
{
	std::ofstream out{ "int 10만개를 바이너리모드 write함수로 기록", std::ios::binary };
	
	std::uniform_int_distribution uid{ std::numeric_limits<int>::min(), std::numeric_limits<int>::max() };

	int num;
	for (int i = 0; i < 10'0000; ++i) {
		num = uid(dre);
		out.write( (char*) & num, sizeof(int));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:49:03 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	
	std::array<int, 100000> a;

	int i{};
	while (in >> a[i]) {
		i++;
	}

	std::cout << *std::min_element(a.begin(), a.end());

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:49:13 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	
	std::array<int, 100000> a;

	int i{};
	while (in >> a[i]) {
		i++;
	}

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:51:07 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록" };
	
	std::array<int, 100000> a;

	int i{};
	while (in >> a[i]) {
		i++;
	}

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:51:14 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	
	std::array<int, 100000> a;

	int i{};
	while (in >> a[i]) {
		i++;
	}

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:51:56 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	int i{};
	while (in >> a[i]) {
		i++;
	}

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:58:00 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:58:41 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	std::cout << "최솟값 - " << * std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:59:26 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록" };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	std::cout << "최솟값 - " << * std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:59:34 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	std::cout << "최솟값 - " << * std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 2:59:49 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록" };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	std::cout << "최솟값 - " << * std::min_element(a.begin(), a.end()) << '\n';
	// -2147431498

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 3:02:05 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << "최솟값 - " << * std::min_element(a.begin(), a.end()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-18 오후 3:02:57 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 18일 화요일					(3주 1일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - 파일에 저장하고 읽어 오기
//						--> 파일을 binary모드로 열어야 변환되지 않는다.
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
// int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 이 문제를 해결하는 코드를 답지에 적어라.
// 화면에 출력된 값도 답지에 적어라.

int main()
{

	std::ifstream in { "int 10만개를 바이너리모드 write함수로 기록",std::ios::binary };
	if (not in)
		exit(-20250318);

	std::array<int, 100000> a;

	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << "최솟값 - " << * std::min_element(a.begin(), a.end()) << '\n';
	// -2147431498

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 3:37:29 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary mode로 열어 write 함수로 int 10만개를 기록한
// 파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
// 읽어서 메모리에 모두 저장하라.
// 메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
// 출력된 값을 답지에도 적어라.

int main()
{
	std::ifstream in{ "int 10만개를 바이너리모드 write함수로 기록", std::ios::binary };

	if (not in) return 20250320;

	std::array<int, 10'0000> a;

	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';
	std::cout << *std::max_element(a.begin(), a.end()) << '\n';



	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 3:40:15 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary mode로 열어 write 함수로 int 10만개를 기록한
// 파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
// 읽어서 메모리에 모두 저장하라.
// 메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
// 출력된 값을 답지에도 적어라.

int main()
{
	std::ifstream in{ "int 10만개를 바이너리모드 write함수로 기록", std::ios::binary };

	if (not in) return 20250320;

	std::array<int, 10'0000> a;

	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << *std::min_element(a.begin(), a.end()) << '\n';
	std::cout << *std::max_element(a.begin(), a.end()) << '\n';



	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 3:49:06 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary mode로 열어 write 함수로 int 10만개를 기록한
// 파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
// 읽어서 메모리에 모두 저장하라.
// 메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
// 출력된 값을 답지에도 적어라.
// constexpr란?

int main()
{
	std::ifstream in{ "int 10만개를 바이너리모드 write함수로 기록", std::ios::binary };

	if (not in) return 20250320;

	std::array<int, 10'0000> a;
	in.read( (char*)a.data(), sizeof(int) * a.size());

	auto p = std::minmax_element(a.begin(), a.end());
	std::cout << *p.first << '\n';
	std::cout << *p.second << '\n';

	//-2147431498
	//2147393736


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 3:51:37 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다

// [문제] binary mode로 열어 write 함수로 int 10만개를 기록한
// 파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
// 읽어서 메모리에 모두 저장하라.
// 메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
// 출력된 값을 답지에도 적어라.
// constexpr란?

int main()
{
	std::ifstream in{ "int 10만개를 바이너리모드 write함수로 기록", std::ios::binary };

	if (not in) return 20250320;

	std::array<int, 10'0000> a;
	in.read( (char*)a.data(), sizeof(int) * a.size());

	auto [minAddress, maxAddress] = std::minmax_element(a.begin(), a.end());
	std::cout << *minAddress << '\n';
	std::cout << *maxAddress << '\n';

	//-2147431498
	//2147393736


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:13:58 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - { }", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	Dog dog;
	
	//dog.show();


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:14:42 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		//std::println("[{:7}] - { }", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	Dog dog;
	
	dog.show();


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:15:15 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - ", id);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	Dog dog;
	
	dog.show();


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:15:41 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - ", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	Dog dog;
	
	dog.show();


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:15:59 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - {:}", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	Dog dog;
	
	dog.show();


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:16:59 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - {}", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	Dog dog;
	
	dog.show();


	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:18:25 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - {}", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:21:35 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] class Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 객체 크기 그대로 write 함수를 사용하여 저장하였다.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:7}] - {}", id, name);
	}

private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int Dog::sid{};

int main()
{
	std::ofstream out{ "Dog 10만마리", std::ios::binary };

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out.write((char*)&dog, sizeof(dog));
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:31:58 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	//std::array<Dog, 10'0000> arr;

	//in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	//arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:32:46 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

std::array<Dog, 10'0000> arr;
int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:32:57 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

std::array<Dog, 10'0000> arr;
int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:33:36 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

std::array<Dog, 1'0000> arr;
int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:34:27 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	std::array<Dog, 1'0000> arr;

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:34:48 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	std::array<Dog, 1'0000> arr;

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:35:07 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	std::array<Dog, 10> arr;

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:35:38 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	std::array<Dog, 1'0000> arr;

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:40:23 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	void show() const {
		std::cout << "id : " << id << " / name : " << name << '\n';
	}
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global
};

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };

	if (not in)
		return -1;

	Dog dog;

	int count{};
	while (in.read((char*)&dog, sizeof(Dog))) {
		++count;
	}

	std::cout << "읽은 객체 수 - " << count << '\n';
	/*std::ifstream in{ "Dog 10만마리", std::ios::binary };
	
	if (not in)
		return -1;

	std::array<Dog, 10'0000> arr;

	in.read((char*)arr.data(), sizeof(Dog) * arr.size());
	
	arr.end()->show();*/

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:48:10 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global


	friend std::ostream& operator<< (std::ostream& os, const Dog& dog) {
		return os << dog.name << " - " << dog.id << '\n';
	}
};

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };

	if (not in)
		return -1;

	Dog dog;

	int count{};
	
	in.read((char*)dogs.data(), dogs.size() * sizeof(Dog));
	
	std::cout << dogs[0] << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:48:41 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout를 사용하여 화면에 출력하라. (10분)

class Dog {
public:
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global


	friend std::ostream& operator<< (std::ostream& os, const Dog& dog) {
		return os << dog.name << " - " << dog.id << '\n';
	}
};

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };

	if (not in)
		return -1;

	Dog dog;

	int count{};
	
	in.read((char*)dogs.data(), dogs.size() * sizeof(Dog));
	
	std::cout << dogs.back() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 4:54:16 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// 

class Dog {
public:
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global


	friend std::ostream& operator<< (std::ostream& os, const Dog& dog) {
		return os << dog.name << " - " << dog.id;
	}

	friend void operator>> (std::istream& is, Dog& dog) {
		is.read((char*)&dog, sizeof(Dog));
	}
};

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	if (not in)
		return -1;

	// [문제] 다음 코드가 수정없이 실행되도록 필요한 코드를 class Dog에 추가하라.
	for (Dog& dog : dogs) {
		in >> dog;
		std::cout << dog << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-20 오후 5:03:02 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 20일 화요일					(3주 2일)
//------------------------------------------------------------------
// 많은 수의 자료를 처리하기 - Dog를 읽고 쓴다, read/write
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] e-class에서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.

class Dog {
public:
	
private:
	std::string name;
	int id;

	static int sid;		// scope - local, life time - global


	friend std::ostream& operator<< (std::ostream& os, const Dog& dog) {
		return os << dog.name << " - " << dog.id;
	}

	friend std::istream& operator>> (std::istream& is, Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in{ "Dog 10만마리", std::ios::binary };
	if (not in)
		return -1;

	// [문제] 다음 코드가 수정없이 실행되도록 필요한 코드를 class Dog에 추가하라.
	for (Dog& dog : dogs) {
		in >> dog;						// operator>>(in, dog)
		std::cout << dog << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:17:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10];

	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	delete[] p;
}

int main()
{
	for (int i = 0; i < 10; ++i) {
		f();
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:18:06 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10];
	std::cout << p << '\n';
	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	delete[] p;
}

int main()
{
	for (int i = 0; i < 10; ++i) {
		f();
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:19:06 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10] {};
	std::cout << p << '\n';
	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	delete[] p;
}

int main()
{
	for (int i = 0; i < 10; ++i) {
		f();
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:24:48 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10] {};
	std::cout << p << '\n';
	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	throw 15571557;

	delete[] p;
}

int main()
{
	try {
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:25:41 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10] {};
	std::cout << p << '\n';
	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	delete[] p;

	// 시간이 얼추 흐른 후

	delete[] p;
}

int main()
{
	
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:26:12 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10] {};
	std::cout << p << '\n';
	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	delete[] p;

	// 시간이 얼추 흐른 후

	delete[] p;
}

int main()
{
	
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:26:32 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------

void f()
{
	int* p = new int[10] {};
	std::cout << p << '\n';
	std::cout << "합계 - " << std::accumulate(p, p + 10, 0) << '\n';

	delete[] p;

	// 시간이 얼추 흐른 후

	delete[] p;
}

int main()
{
	
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:28:18 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};


void f()
{
	Dog* p = new Dog;

	delete p;
}

int main()
{
	f();
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:29:42 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};


void f()
{
	Dog* p = new Dog;

	throw 1;

	delete p;
}

int main()
{
	try {
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:39:16 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <numeric>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	smartP p{ new Dog };

	throw 1;
}

int main()
{
	try {
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:41:12 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	std::unique_ptr<Dog> { new Dog };

	throw 1;
}

int main()
{
	try {
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:41:28 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	std::unique_ptr<Dog> { new Dog };

	throw 1;
}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:41:56 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	std::unique_ptr<Dog> asdf { new Dog };

	throw 1;
}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:42:04 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	std::unique_ptr<Dog> asdf { new Dog };

}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:42:39 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	std::unique_ptr<Dog> asdf { new Dog };

	std::cout << "이 줄이 출력될 수 없다" << '\n';
}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:44:09 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	std::unique_ptr<Dog> asdf = std::make_unique<Dog>();

	std::cout << "이 줄이 출력될 수 없다" << '\n';
}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:45:12 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	int num{ 5 };
	std::unique_ptr<Dog[]> asdf = std::make_unique<Dog[]>(num);

	std::cout << "이 줄이 출력될 수 없다" << '\n';
}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 2:45:22 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
class Dog {
public:
	Dog() { std::cout << "생성" << '\n'; }
	~Dog() { std::cout << "소멸" << '\n'; }

};

class smartP {
	Dog* p;
public:
	smartP(Dog* p) : p{ p } {}
	~smartP() {
		delete p;
	}
};

void f()
{
	int num{ -1 };
	std::unique_ptr<Dog[]> asdf = std::make_unique<Dog[]>(num);

	std::cout << "이 줄이 출력될 수 없다" << '\n';
}

int main()
{
	try {
		f();
	}
	catch (...) {
		std::cout << "예외" << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 3:02:33 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <memory>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
// [문제] "main.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "main upper.cpp"에 저장하시오
//------------------------------------------------------------------



int main()
{
	std::ifstream in{ "main.cpp" };
	
	if (not in)
		return -1557;

	std::ofstream out{ "main upper.cpp" };
	
	char c;
	while (in >> c) {
		if (islower(c))
			c = toupper(c);
		out << c;
	}


	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 3:03:44 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <memory>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
// [문제] "main.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "main upper.cpp"에 저장하시오
//------------------------------------------------------------------



int main()
{
	std::ifstream in{ "main.cpp" };
	
	if (not in)
		return -1557;

	std::ofstream out{ "main upper.cpp" };
	
	char c;
	in >> std::noskipws;
	while (in >> c) {
		if (islower(c))
			c = toupper(c);
		out << c;
	}


	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 3:04:07 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <memory>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
// [문제] "main.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "main upper.cpp"에 저장하시오
//------------------------------------------------------------------



int main()
{
	std::ifstream in{ "main.cpp" };
	
	if (not in)
		return -1557;

	std::ofstream out{ "main upper.cpp" };
	
	char c;
	in >> std::noskipws;
	while (in >> c) {
		c = toupper(c);
		out << c;
	}


	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-25 오후 3:09:22 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 25일 화요일					(4주 1일)
//------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

//------------------------------------------------------------------
// 1. STACK
// 2. DATA
// 3. free-store
// 1,2번과 3번의 차이	- 메모리 크기를 언제 결정할 수 있는가
// 1번과 2번의 차이		- 메모리 크기가 얼마나 큰가
// 
// 다음 시간 이거 조금 더 설명하고 smart pointer로 직행 - 왜 RAII가 중요한가
//------------------------------------------------------------------
// [문제] "main.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "main upper.cpp"에 저장하시오
//------------------------------------------------------------------



int main()
{
	std::ifstream in{ "main.cpp" };
	if (not in)
		return -1557;

	std::ofstream out{ "main upper.cpp" };
	
	std::transform(std::istreambuf_iterator<char>(in), {},
		std::ostreambuf_iterator<char>(out),
		[](char c) { return toupper(c); });
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 3:48:22 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	for (int i = 0; i < 1000;++i) {
		std::print("{:8}", (*upArray)[i]);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 3:54:05 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	for (int num : *upArray | std::ranges::views::take(100)) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 3:54:56 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	for (int num : *upArray | std::ranges::views::take(5)
							| std::ranges::views::take(1) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 3:55:14 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	for (int num : *upArray | std::ranges::views::take(5)
							| std::ranges::views::take(1) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 3:55:28 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	for (int num : *upArray | std::ranges::views::take(5) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:17:05 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

// 바꿔야 하면 1
// // 이미 정렬 상태이면 -1
// 둘이 정렬 기준상 동일한 값이면 0
int ascendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// qsort로 오름차순 정렬
	std::qsort(upArray->data(), upArray->size(), sizeof(std::array<int, 1'000'000>::value_type), ascendingOrder);


	// 앞에서 부터 1000개를 화면 출력

	for (int num : *upArray | std::ranges::views::take(1000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:17:49 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

// 바꿔야 하면 1
// // 이미 정렬 상태이면 -1
// 둘이 정렬 기준상 동일한 값이면 0
int ascendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// qsort로 오름차순 정렬
	std::qsort(upArray->data(), upArray->size(), sizeof(std::array<int, 1'000'000>::value_type), ascendingOrder);


	// 앞에서 부터 1000개를 화면 출력

	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:19:44 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

// 바꿔야 하면 1
// // 이미 정렬 상태이면 -1
// 둘이 정렬 기준상 동일한 값이면 0
int ascendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int descendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p > *q)
		return -1;
	else if (*p < *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// qsort로 내림차순 정렬
	std::qsort(upArray->data(), upArray->size(), sizeof(std::array<int, 1'000'000>::value_type), descendingOrder);


	// 앞에서 부터 1000개를 화면 출력

	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:21:08 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

// 바꿔야 하면 1
// // 이미 정렬 상태이면 -1
// 둘이 정렬 기준상 동일한 값이면 0
int ascendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int descendingOrder(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// qsort로 내림차순 정렬
	std::qsort(upArray->data(), upArray->size(), sizeof(std::array<int, 1'000'000>::value_type), descendingOrder);


	// 앞에서 부터 1000개를 화면 출력

	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:21:19 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

// 바꿔야 하면 1
// // 이미 정렬 상태이면 -1
// 둘이 정렬 기준상 동일한 값이면 0
int ascendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int descendingOrder(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// qsort로 내림차순 정렬
	std::qsort(upArray->data(), upArray->size(), sizeof(std::array<int, 1'000'000>::value_type), descendingOrder);


	// 앞에서 부터 1000개를 화면 출력

	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:27:24 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// qsort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

// 바꿔야 하면 1
// // 이미 정렬 상태이면 -1
// 둘이 정렬 기준상 동일한 값이면 0
int ascendingOrder(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;

	return 0;

	//const int* p = (const int*)a;
	//int* pp = (int*)b;

}

int descendingOrder(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	int (* orderStandard)(const void*, const void*) = ascendingOrder;

	std::qsort(upArray->data(), upArray->size(), sizeof(int), orderStandard);


	// 앞에서 부터 1000개를 화면 출력

	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:46:38 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;


int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬
	std::sort(upArray->begin(), upArray->end());


	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:48:58 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;


int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬
	std::sort(upArray->rbegin(), upArray->rend());


	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:54:40 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <


	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:57:19 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:57:49 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:58:23 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:58:48 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:58:53 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:58:58 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:59:07 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 4:59:12 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:00:09 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';
	std::cout << "경과시간(ms) - " << (e - b) / 100 << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:00:47 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';
	std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:01:12 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };

	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	for (int& num : *upArray) {
		num = uid(dre);
	}

	// 정렬에 걸리는 시간 측정
	auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
	std::sort(upArray->begin(), upArray->end(),ascendingOrder );			// 디폴트 정렬 operator <
	auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

	// 앞에서 부터 1000개를 화면 출력
	for (int num : *upArray | std::ranges::views::take(3000) ) {
		std::print("{:8}", num);
	}
	
	std::cout << "경과시간(duration) - " << e - b << '\n';
	std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:04:17 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };
	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	{
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(), ascendingOrder);			// 디폴트 정렬 operator <
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	{	// 내림차순으로 정렬
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(),[](const int a, const int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:04:55 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };
	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	{
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(), ascendingOrder);			// 디폴트 정렬 operator <
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	{	// 내림차순으로 정렬
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(),[](const int a, const int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:05:24 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };
	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	{
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(), [](const int a, const int b) {
			return a < b;
			});			// 디폴트 정렬 operator <
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	{	// 내림차순으로 정렬
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(),[](const int a, const int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:07:00 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };
	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	{
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(), ascendingOrder);			// 디폴트 정렬 operator <
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	{	// 내림차순으로 정렬
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(),[](const int a, const int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:07:13 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };
	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	{
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(), ascendingOrder);			// 디폴트 정렬 operator <
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	{	// 내림차순으로 정렬
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(),[](const int a, const int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-03-27 오후 5:10:11 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	3월 27일 목요일					(4주 2일)
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <random>
#include <array>
#include <memory>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

std::default_random_engine dre;

bool ascendingOrder(const int a, const int b)
{
	return a < b;
}

int main()
{
	std::uniform_int_distribution uid{ 0,9'999'999 };
	std::unique_ptr<std::array<int, 10'000'000>> upArray = std::make_unique<std::array<int, 10'000'000>>();

	{
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort(upArray->begin(), upArray->end(), ascendingOrder);			// 디폴트 정렬 operator <
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	{	// 내림차순으로 정렬
		for (int& num : *upArray) {
			num = uid(dre);
		}
		// 정렬에 걸리는 시간 측정
		auto b = std::chrono::high_resolution_clock::now();						// 스톱워치 시작
		std::sort<std::array<int,10'000'000>::iterator>(upArray->begin(), upArray->end(),[](const int a, const int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();						// 스톱워치 끝

		/*for (int num : *upArray | std::ranges::views::take(3000)) {
			std::print("{:8}", num);
		}*/
		std::cout << "경과시간(ms) - " << std::chrono::duration_cast<std::chrono::milliseconds>(e - b) << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:34:59 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?

	[]() {
		std::cout << "ㅎㅇ" << std::endl;

		}();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:36:26 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?

	typeid([]() {
		std::cout << "ㅎㅇ" << std::endl;

		});

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:37:33 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?
	std::cout <<
	typeid([]() {
		std::cout << "ㅎㅇ" << std::endl;

		}).name() << '\n';;

	save("main.cpp");
	
}

=================================================
저장한 시간: 2025-04-01 오후 1:39:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?
	std::cout << "람다 1의 정체 - " <<
	typeid([]() {
		std::cout << "ㅎㅇ" << std::endl;

		}).name()
			<< '\n';

	std::cout << "람다 2의 정체 - " <<
		typeid([]() {
		std::cout << "ㅎㅇ" << std::endl;
			}).name()
			<< '\n';
	save("main.cpp");
	
}

=================================================
저장한 시간: 2025-04-01 오후 1:40:21 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?
	std::cout << "람다 1의 정체 - " <<
		typeid([]() {
			std::cout << "ㅎㅇ" << std::endl;
		}).name()
		<< '\n';

	save("main.cpp");
	
}

=================================================
저장한 시간: 2025-04-01 오후 1:43:34 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?
	
	auto asdf = save;
	std::cout << asdf << '\n';
	save("main.cpp");
	
}

=================================================
저장한 시간: 2025-04-01 오후 1:44:04 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

// [문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값의 범위는 [0, 10'000'000) ===> 0부터 9'999'999까지 값을 갖도록
// C++ 언어의 sort를 사용하여 오름차순으로 정렬하라
// 정렬한 결과를 앞에서 부터 1000개만 화면에 출력하라

int main()
{
	// 람다는 도대체 무엇인가?
	
	int* asdf = (int*)save;
	std::cout << asdf << '\n';
	save("main.cpp");
	
}

=================================================
저장한 시간: 2025-04-01 오후 1:49:54 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class DOG {
public:
	void operator()() {
		std::cout << "왜" << '\n';
	}
};

int main()
{
	DOG dog;
	
	dog();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:51:00 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class DOG {
public:
	bool operator()(int a, int b) {
		return a < b;
	}
};

int main()
{
	DOG dog;
	
	dog(1,2);

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:51:16 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class DOG {
public:
	bool operator()(int a, int b) {
		return a < b;
	}
};

int main()
{
	DOG dog;
	
	std::cout<<dog(1,2)<<'\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:51:48 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class DOG {
public:
	bool operator()(int a, int b) {
		return a < b;
	}
};

int main()
{
	DOG dog;
	
	std::cout << typeid(dog).name() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:52:05 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?



int main()
{
	class DOG {
	public:
		bool operator()(int a, int b) {
			return a < b;
		}
	};

	DOG dog;
	
	std::cout << typeid(dog).name() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:52:49 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?



int main()
{
	std::cout << typeid(
	[]() {

		}).name() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 1:53:09 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>

#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?



int main()
{
	std::cout << typeid(
	[]() {

		}).name() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:09:45 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

	class Dog {
	public:
		bool operator()(const int& a, const int& b) const {
			return a > b;
		}
	};

	std::sort(a.begin(), a.end(), Dog {});

	for (const int& num : a) {
		std::cout << num;
	}
	std::cout << '\n';			// 10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:13:28 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

	auto Dog = [](int a, int b)->bool {
		return a > b;
		};

	std::sort(a.begin(), a.end(), Dog);

	for (const int& num : a) {
		std::cout << num;
	}
	std::cout << '\n';			// 10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:13:39 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

	auto Dog = [](int a, int b)->bool {
		return a > b;
		};

	std::sort(a.begin(), a.end(), Dog);

	for (const int& num : a) {
		std::cout << num << ' ';
	}
	std::cout << '\n';			// 10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:15:26 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	// [문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

	class Dog {
	public:
		bool operator()(int a, int b) const {
			return a > b;
		}
	};

	std::sort(a.begin(), a.end(), Dog{});

	for (const int& num : a) {
		std::cout << num << ' ';
	}
	std::cout << '\n';			// 10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:27:14 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
// 5. 멤버함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	auto p = [](int a, int b) {return a > b; };

	std::cout << std::boolalpha << p(3, 4) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:28:58 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입		--------> 모든 것을 대표하는 function
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
// 5. 멤버함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <functional>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	auto p = [](int a, int b) {return a > b; };


	std::function<bool(int,int)> DescendingDrder = p;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:29:17 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사 - 4월 24일 목요일
//------------------------------------------------------------------
// Callable type - 호출가능한 타입		--------> 모든 것을 대표하는 function
// 1. 함수
// 2. 함수포인터
// 3. 람다 - 이름없는 함수 - 실체가 있어야 한다.(VS class로 코딩)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
// 5. 멤버함수
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <functional>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

int main()
{
	auto p = [](int a, int b) {return a > b; };


	std::function<bool(int,int)> DescendingDrder = p;

	std::cout << DescendingDrder(3, 4) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:38:58 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const{
		std::print("{:12} - {}\n", id, name);
	}
private:
	std::string name;
	int id;
};

int main()
{
	std::array<Dog, 10> dogs;
	for (const Dog& dog: dogs) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:39:05 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const{
		std::print("{:12} - {}\n", id, name);
	}
private:
	std::string name;
	int id;
};

int main()
{
	std::array<Dog, 10> dogs;
	for (const Dog& dog: dogs) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:39:19 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <array>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
			name = "123";
		}
		id = uidId(dre);
	}

	void show() const{
		std::print("{:12} - {}\n", id, name);
	}
private:
	std::string name;
	int id;
};

int main()
{
	std::array<Dog, 10> dogs;
	for (const Dog& dog: dogs) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:45:08 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <array>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const{
		std::print("{:12} - {}\n", id, name);

	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}
private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// std::ofstream out("Dog 십만마리");
// 
// Dog dog;
// out << dog;
// ostream& operator<<( ostream& os, const Dog& dog ) {
//		return os << dog.id << " " << dog.name << " ";
// }

int main()
{
	std::ofstream out("Dog 십만마리");

	for (int i = 0; i < 10; ++i) {
		Dog dog;
		out << dog;
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:45:19 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <array>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const{
		std::print("{:12} - {}\n", id, name);

	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}
private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// std::ofstream out("Dog 십만마리");
// 
// Dog dog;
// out << dog;
// ostream& operator<<( ostream& os, const Dog& dog ) {
//		return os << dog.id << " " << dog.name << " ";
// }

int main()
{
	std::ofstream out("Dog 십만마리");

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 2:46:04 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <array>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const{
		std::print("{:12} - {}\n", id, name);

	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}
private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// std::ofstream out("Dog 십만마리");
// 
// Dog dog;
// out << dog;
// ostream& operator<<( ostream& os, const Dog& dog ) {
//		return os << dog.id << " " << dog.name << " ";
// }

int main()
{
	std::ofstream out("Dog 십만마리");

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << std::noskipws;
		out << dog;
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-01 오후 3:08:48 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <memory>
#include <array>
#include <fstream>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}
private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000 > dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	for (int i = 0; i < 10'0000; ++i) {
		int id;
		std::string name;
		in >> id >> name;
		dogs[i].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:21:49 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <memory>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {

		return id;
	}
private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000 > dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	for (int i = 0; i < 10'0000; ++i) {
		int id;
		std::string name;
		in >> id >> name;
		dogs[i].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getId() < b.getId();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:22:41 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <memory>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {
		return id;
	}

	std::string getName() {
		return name;
	}

private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000 > dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	for (int i = 0; i < 10'0000; ++i) {
		int id;
		std::string name;
		in >> id >> name;
		dogs[i].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getName().length() < b.getName().length();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:23:21 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 1일 화요일				(5주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <memory>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {
		return id;
	}

	std::string getName() {
		return name;
	}

private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000 > dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> id >> name;
		dogs[i].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getName().length() < b.getName().length();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:33:25 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {
		return id;
	}

	std::string getName() {
		return name;
	}

private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> id >> name;
		dogs[i].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getName().length() < b.getName().length();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:36:19 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {
		return id;
	}

	std::string getName() {
		return name;
	}

	

private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	int i{};
	while(in >> id >> name) {
		dogs[i++].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getName().length() < b.getName().length();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:39:10 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {
		return id;
	}

	std::string getName() {
		return name;
	}

	

private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	int count{};
	while(in >> id >> name) {
		std::println("[{:7}] : {:12} - {}", count, id, name);
		dogs[count++].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getName().length() < b.getName().length();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:39:33 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:
	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	void setDog(int inputId, std::string inputName) {
		name = inputName;
		id = inputId;
	}

	int getId() {
		return id;
	}

	std::string getName() {
		return name;
	}

	

private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	int count{};
	while(in >> id >> name) {
		std::println("{:7} : {:12} - {}", count, id, name);
		dogs[count++].setDog(id, name);
	}

	std::cout << *(dogs.rbegin()) << '\n';

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.getName().length() < b.getName().length();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:47:38 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:9} - {}", id, name);
	}

	size_t nameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.nameLength() < b.nameLength();
		});

	for (int i = 0; i < 1000; ++i) {
		std::cout << dogs[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:47:52 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:9} - {}", id, name);
	}

	size_t nameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.nameLength() < b.nameLength();
		});

	for (int i = 0; i < 1000; ++i) {
		dogs.back().show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:48:06 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:9} - {}", id, name);
	}

	size_t nameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {
		return a.nameLength() < b.nameLength();
		});

	for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:55:54 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:9} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}
	
	int id;
	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNameLength() < b.getNameLength();
		});

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:56:20 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNameLength() < b.getNameLength();
		});

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:57:51 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNameLength() < b.getNameLength();
		});

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs | std::views::take(1000)) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 3:59:04 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}



private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNameLength() < b.getNameLength();
		});

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs | std::views::reverse | std::views::take(1000)) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:03:40 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}
	
	friend bool operator<(Dog a, Dog b) {
		return a.getNameLength() < b.getNameLength();
	}


private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end());

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs | std::views::reverse | std::views::take(1000)) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:04:53 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}
	
	bool operator<(const Dog& rhs) {
		return getNameLength() < rhs.getNameLength();
	}


private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end());

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs | std::views::reverse | std::views::take(1000)) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:05:35 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}
	
	bool operator<(const Dog& rhs) const {
		return name.length() < rhs.name.length();
	}


private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end());

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs | std::views::reverse | std::views::take(1000)) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:05:48 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
//------------------------------------------------------------------
// Callable
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
#include <iostream>
#include <string>
#include <random>
#include <array>
#include <fstream>
#include <algorithm>
#include <print>
#include <ranges>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

std::default_random_engine dre;
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution<int> uidNameLength{ 3, 30 };
std::uniform_int_distribution<int> uidId{};

class Dog {
public:

	Dog() {
		int nNameLength = uidNameLength(dre);
		for (int i = 0; i < nNameLength; ++i) {
			name += uidName(dre);
		}
		id = uidId(dre);
	}

	void show() const {
		std::println("{:13} - {}", id, name);
	}

	size_t getNameLength() const {
		return name.length();
	}

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		is >> dog.id >> dog.name;
		return is;
	}
	
	bool operator<(const Dog& rhs) const {
		return name.length() < rhs.name.length();
	}


private:
	std::string name;
	int id;
};

// [문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다.
//		std::ofstream out("Dog 십만마리");
// 
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
//
// [문제] 파일 "Dog 십만마리"에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

std::array<Dog, 10'0000> dogs;

int main()
{
	std::ifstream in("Dog 십만마리");

	if (not in) {
		return -1557;
	}

	std::string name;
	for (int i = 0; i < 10'0000; ++i) {
		in >> dogs[i];
	}

	dogs.back().show();

	std::sort(dogs.begin(), dogs.end());

	/*for (int i = 0; i < 1000; ++i) {
		dogs[i].show();
	}*/

	for (const Dog& dog: dogs | std::views::take(1000)) {
		dog.show();
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:37:57 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {

};
	
int main()
{
	std::string s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:44:55 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}
	STRING(const char* in) {
		strSize = sizeof(in);
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}
	~STRING() {
		delete[] str;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, STRING s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:45:24 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}
	STRING(const char* in) {
		strSize = sizeof(in);
		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}
	~STRING() {
		delete[] str;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, STRING s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:50:34 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}
	STRING(const char* in) {
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}
	~STRING() {
		delete[] str;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, STRING s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:50:49 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}
	STRING(const char* in) {
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}
	~STRING() {
		delete[] str;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, STRING s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수
	std::cout << 1557;
	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:51:13 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}
	STRING(const char* in) {
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}
	~STRING() {
		std::cout << 1557;
		delete[] str;
		std::cout << 1557;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, STRING s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:51:28 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}
	STRING(const char* in) {
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}

	~STRING() {
		std::cout << 1557;
		delete[] str;
		std::cout << 1557;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, STRING s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:52:26 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}

	STRING(const char* in) {
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}

	~STRING() {
		std::cout << 1557;
		delete[] str;
		std::cout << 1557;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, const STRING& s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:52:41 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}

	STRING(const char* in) {
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}

	~STRING() {
		std::cout << 1557;
		delete[] str;
		std::cout << 1557;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, const STRING& s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:53:25 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}

	STRING(const char* in) {			// [] -> *로 collapsing
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}

	~STRING() {
		delete[] str;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, const STRING& s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 4:53:40 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING() {
		str = NULL;
		strSize = 0;
	}

	STRING(const char* in) {			// [] -> *로 collapsing
		
		int count{};
		while (1) {
			if (in[++count] == 0) {
				strSize = count;
				break;
			}
		}

		std::cout << in << '\n';
		str = new char[strSize];
		for (int i = 0; i < strSize; ++i) {
			str[i] = in[i];
		}
	}

	~STRING() {
		delete[] str;
	}

	size_t size() const {
		return strSize;
	}

	friend std::ostream& operator<<(std::ostream& os, const STRING& s) {
		os << s.str;
		return os;
	}

private:
	char* str;
	size_t strSize;
};
	
int main()
{
	STRING s{ "std::String" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 5:07:31 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING(const char* in) : length{ strlen(in) } {			// [] -> *로 collapsing
		pStr.reset();
		pStr = std::make_unique<char[]>(length);

		memcpy(pStr.get(), in, length);							// DMA
	}

	size_t size() const {
		return length;
	}

	

private:
	size_t length;
	std::unique_ptr<char[]> pStr;


	friend std::ostream& operator<< ( std::ostream & os, const STRING& str ) {
		os << str;
		return os;
	}
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 5:07:50 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING(const char* in) : length{ strlen(in) } {			// [] -> *로 collapsing
		pStr.reset();
		pStr = std::make_unique<char[]>(length);

		memcpy(pStr.get(), in, length);							// DMA
	}

	size_t size() const {
		return length;
	}

	

private:
	size_t length;
	std::unique_ptr<char[]> pStr;


	friend std::ostream& operator<< ( std::ostream & os, const STRING& str ) {
		os << str.pStr;
		return os;
	}
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 5:10:45 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING(const char* in) : length{ strlen(in) } {			// [] -> *로 collapsing
		pStr.reset();
		pStr = std::make_unique<char[]>(length);

		memcpy(pStr.get(), in, length);							// DMA
	}

	size_t size() const {
		return length;
	}

	

private:
	size_t length;
	std::unique_ptr<char[]> pStr;


	friend std::ostream& operator<< ( std::ostream & os, const STRING& str ) {
		for (int i = 0; i < str.length; ++i) {
			os << str.pStr[i];
		}
		return os;
	}
};
	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-03 오후 5:11:10 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?

class STRING {
public:
	STRING(const char* in) : length{ strlen(in) } {			// [] -> *로 collapsing
		pStr.reset();
		pStr = std::make_unique<char[]>(length);

		memcpy(pStr.get(), in, length);							// DMA
	}

	size_t size() const {
		return length;
	}

	

private:
	size_t length;
	std::unique_ptr<char[]> pStr;


	friend std::ostream& operator<< ( std::ostream & os, const STRING& str ) {
		for (int i = 0; i < str.length; ++i) {
			os << str.pStr[i];
		}
		return os;
	}
};
	
int main()
{
	STRING s{ "st" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 1:38:37 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 1:49:43 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << s << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 1:49:54 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 1:50:16 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 1:54:59 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	std::cout << "1" << '\n';
	STRING t;
	std::cout << "2" << '\n';
	t = s;
	std::cout << "3" << '\n';
	STRING u = s;
	std::cout << "4" << '\n';

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:19:31 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:31:08 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:32:15 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:32:36 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:33:00 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:35:29 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:36:23 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING s{ "std::String과 유사한 클래스" };

	std::cout << s.size() << '\n';			// s가 확보한 자원의 Byte수

	std::cout << s << '\n';

	STRING t;
	t = s;

	STRING u = s;

	std::cout << t << '\n';
	std::cout << u << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:37:35 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:39:09 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:39:58 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:40:40 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:42:43 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:43:15 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?


	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:49:35 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:50:05 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool 관찰;					// 관찰하려면 true로 설정

int main()
{
	STRING t;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:51:13 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool 관찰;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	STRING t = s;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:52:10 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool 관찰;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	STRING t = s;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:53:33 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool 관찰;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	std::cout << "hi main" << '\n';
	STRING t = s;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:55:05 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool 관찰;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	std::cout << "hi main" << '\n';
	STRING t = s;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 2:57:23 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	watching = false;
	std::cout << "hi main" << '\n';
	STRING t = s;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:00:41 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라

	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			return rhs.size() < lhs.size();
		});

	for (const STRING& str : a) {
		std::cout << str << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:01:38 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라

	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			std::cout << "비교 : " << rhs << '/' << lhs << '\n';
			return rhs.size() < lhs.size();
		});

	for (const STRING& str : a) {
		std::cout << str << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:05:32 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

STRING s { "이제 준비가 끝났다"};

int main()
{
	watching = false;

	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라

	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			return rhs.size() < lhs.size();
		});

	for (const STRING& str : a) {
		std::cout << str << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:06:46 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	watching = false;

	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라

	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			return rhs.size() < lhs.size();
		});

	
	watching = true;
	for (const STRING& str : a) {
		std::cout << str << '\n';
	}
	watching = false;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:07:09 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	watching = false;

	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라

	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			return rhs.size() < lhs.size();
		});

	
	watching = true;
	for (const auto& str : a) {
		std::cout << str << '\n';
	}
	watching = false;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:08:09 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	watching = false;

	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라
	watching = true;
	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			return rhs.size() < lhs.size();
		});
	watching = false;
	
	
	for (const STRING& str : a) {
		std::cout << str << '\n';
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:10:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	watching = false;

	std::array<STRING, 5> a{ "1", "333", "22" , "55555", "4444" };

	// 길이 기준 오름차순 정렬하고 출력하라
	watching = true;
	std::sort(a.begin(), a.end(),
		[](const STRING& rhs, const STRING& lhs) {
			return rhs.size() < lhs.size();
		});
	watching = false;
	
	
	for (const STRING& str : a) {
		std::cout << str << '\n';
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-08 오후 3:12:10 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 3일 화요일				(5주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 과제		(30) - 4월 10일 설명
// 문제 1 - 파일을 읽어(text/binary) 메모리에 저장한 후 다루는 문제?
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	STRING s{ "표준 string " };
	STRING t = std::move(s);

	std::cout << s << '\n';
	std::cout << t << '\n';
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-10 오후 3:51:03 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 10일 화요일				(6주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	
	STRING s{ "표준 string " };
	STRING t = std::move(s);

	std::cout << "s - " << s << '\n';
	std::cout << "t - " << t << '\n';
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-10 오후 3:52:52 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 10일 화요일				(6주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	
	std::string s{ "표준 string " };
	std::string t = std::move(s);

	std::cout << "s - " << s << '\n';
	std::cout << "t - " << t << '\n';
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-10 오후 3:53:24 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 10일 화요일				(6주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
	
extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	watching = true;

	STRING s{ "표준 string " };
	STRING t = std::move(s);

	std::cout << "s - " << s << '\n';
	std::cout << "t - " << t << '\n';
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-10 오후 4:25:14 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 10일 화요일				(6주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	watching = true;

	STRING s{ "표준 string " };
	STRING t = std::move(s);

	//std::cout << "s - " << s << '\n';
	std::cout << "t - " << t << '\n';
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-10 오후 4:40:57 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 10일 화요일				(6주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	watching = true;

	STRING s{ "표준 string " };
	STRING t = std::move(s);

	//std::cout << "s - " << s << '\n';
	std::cout << "t - " << t << '\n';
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-10 오후 4:41:06 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 10일 화요일				(6주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	watching = true;

	STRING s{ "표준 string " };
	STRING t = std::move(s);

	std::cout << "s - " << s << '\n';
	std::cout << "t - " << t << '\n';
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-10 오후 5:00:39 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 10일 화요일				(6주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::array<STRING, 5> a{ "1","333","55555", "22", "333" };

	// 정렬
	std::sort(a.begin(), a.end(), [](const STRING& lhs, const STRING rhs){
		return lhs.size() < rhs.size();
		})
		;

	// 출력
	for (const STRING& str : a) {
		std::cout << str << '\n';
	}


	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-10 오후 5:00:49 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 10일 화요일				(6주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::array<STRING, 5> a{ "1","333","55555", "22", "444" };

	// 정렬
	std::sort(a.begin(), a.end(), [](const STRING& lhs, const STRING rhs){
		return lhs.size() < rhs.size();
		})
		;

	// 출력
	for (const STRING& str : a) {
		std::cout << str << '\n';
	}


	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-10 오후 5:01:06 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 10일 화요일				(6주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	watching = true;

	std::array<STRING, 5> a{ "1","333","55555", "22", "4444" };

	// 정렬
	std::sort(a.begin(), a.end(), [](const STRING& lhs, const STRING rhs){
		return lhs.size() < rhs.size();
		})
		;

	// 출력
	for (const STRING& str : a) {
		std::cout << str << '\n';
	}


	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-10 오후 5:01:57 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 10일 화요일				(6주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	

	std::array<STRING, 5> a{ "1","333","55555", "22", "4444" };
	watching = true;
	// 정렬
	std::sort(a.begin(), a.end(), [](const STRING& lhs, const STRING rhs){
		return lhs.size() < rhs.size();
		})
		;

	// 출력
	for (const STRING& str : a) {
		std::cout << str << '\n';
	}


	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-10 오후 5:02:21 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 10일 화요일				(6주 2일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			내부 동작을 관찰할 수 있게 하자
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	

	std::array<STRING, 5> a{ "1","333","55555", "22", "4444" };
	watching = true;
	// 정렬
	std::sort(a.begin(), a.end(), [](const STRING& lhs, const STRING& rhs){
		return lhs.size() < rhs.size();
		})
		;
	watching = false;
	// 출력
	for (const STRING& str : a) {
		std::cout << str << '\n';
	}


	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 2:19:19 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::cout << typeid(std::array<int, 0>::value_type).name();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 2:26:34 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::array<int, 0> a;

	std::cout << "빈 어레이니? - " << std::boolalpha << a.empty() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 2:26:42 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::array<int, 1> a;

	std::cout << "빈 어레이니? - " << std::boolalpha << a.empty() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 2:29:31 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::array<int, 5> a{ 1, 2, 3, 4, 5 };			// int a[5]

	for (int i = -10; i < 10; ++i) {
		std::cout << a[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 2:29:53 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::array<int, 5> a{ 1, 2, 3, 4, 5 };			// int a[5]

	for (int i = -10; i < 10; ++i) {
		std::cout << a[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 2:30:10 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::array<int, 6> a{ 1, 2, 3, 4, 5, 6 };			// int a[5]

	for (int i = -10; i < 10; ++i) {
		std::cout << a[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 2:43:26 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::vector<int> v{ 1, 2 ,3 };		// { } - initializer-list
	
	// v의 정체를 밝혀보세요.
	std::cout << "v의 크기 - " << sizeof(v) << '\n';
	std::cout << "v의 주소 - " << addressof(v) << '\n';
	std::cout << "v의 타입 - " << typeid(v).name() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 2:44:34 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic
std::vector<int> v{ 1, 2 ,3 };		// { } - initializer-list
extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	
	
	// v의 정체를 밝혀보세요.
	std::cout << "v의 크기 - " << sizeof(v) << '\n';
	std::cout << "v의 주소 - " << addressof(v) << '\n';
	std::cout << "v의 타입 - " << typeid(v).name() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 2:44:41 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::vector<int> v{ 1, 2 ,3 };		// { } - initializer-list
	
	// v의 정체를 밝혀보세요.
	std::cout << "v의 크기 - " << sizeof(v) << '\n';
	std::cout << "v의 주소 - " << addressof(v) << '\n';
	std::cout << "v의 타입 - " << typeid(v).name() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 2:45:18 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::vector<int>* v = new std::vector<int> { 1, 2 ,3 };		// { } - initializer-list
	
	// v의 정체를 밝혀보세요.
	std::cout << "v의 크기 - " << sizeof(v) << '\n';
	std::cout << "v의 주소 - " << addressof(v) << '\n';
	std::cout << "v의 타입 - " << typeid(v).name() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 2:45:35 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::vector<int>* v = new std::vector<int> { 1, 2 ,3 };		// { } - initializer-list
	
	// v의 정체를 밝혀보세요.
	std::cout << "v의 크기 - " << sizeof(*v) << '\n';
	std::cout << "v의 주소 - " << addressof(*v) << '\n';
	std::cout << "v의 타입 - " << typeid(*v).name() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 2:54:16 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::vector<int> v{ 1, 2 ,3 };		// { } - initializer-list
	
	// 반복자를 사용하여 access
	for (std::vector<int>::iterator i = v.begin(); i != v.end(); ++i) {
		std::cout << *i << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 3:03:24 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::vector<int> v{ 1, 2 ,3 };		// { } - initializer-list
	
	// 반복자를 사용하여 access
	for (auto i = v.cbegin(); i != v.cend(); ++i) {
		std::cout << *i << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 3:03:32 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::vector<int> v{ 1, 2 ,3 };		// { } - initializer-list
	
	// 반복자를 사용하여 access
	for (auto i = v.crbegin(); i != v.crend(); ++i) {
		std::cout << *i << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 3:09:14 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] 키보드에서 입력한 정수값의 합계와 평균을 출력하라.

int main()
{
	std::cout << "정수를 마음껏 입력하라" << '\n';

	std::vector<int> v{ std::istream_iterator<int>{std::cin}, {} };

	long long sum{ std::accumulate(v.begin(), v.end(), 0LL) };
	std::cout << "합계입니다." << sum << '\n';
	std::cout << "합계입니다." << double(sum) / v.size() << '\n';
	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 3:09:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] 키보드에서 입력한 정수값의 합계와 평균을 출력하라.

int main()
{
	std::cout << "정수를 마음껏 입력하라" << '\n';

	std::vector<int> v{ std::istream_iterator<int>{std::cin}, {} };

	long long sum{ std::accumulate(v.begin(), v.end(), 0LL) };
	std::cout << "합계입니다." << sum << '\n';
	std::cout << "합계입니다." << double(sum) / v.size() << '\n';
	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-15 오후 3:10:01 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오


//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] 키보드에서 입력한 정수값의 합계와 평균을 출력하라.

int main()
{
	std::cout << "정수를 마음껏 입력하라" << '\n';

	std::vector<int> v{ std::istream_iterator<int>{std::cin}, {} };

	long long sum{ std::accumulate(v.begin(), v.end(), 0LL) };
	std::cout << "합계입니다. - " << sum << '\n';
	std::cout << "평균입니다. - " << double(sum) / v.size() << '\n';
	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 3:40:13 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] 키보드에서 입력한 단어를 오름차순 정렬한 후 출력하라.

int main()
{
	std::vector<std::string> v{ std::istream_iterator<std::string>{std::cin}, {} };			// 키보드 입력 시작/끝

	std::sort(v.begin(), v.end());					// string < string
	
	for (const std::string& str : v) {
		std::cout << str << '\n';
	}


	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 3:41:59 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] 키보드에서 입력한 단어를 오름차순 정렬한 후 출력하라.

int main()
{
	std::vector<std::string> v{ std::istream_iterator<std::string>{std::cin}, {} };			// 키보드 입력 시작/끝

	std::sort(v.begin(), v.end());					// string < string
	
	for (const std::string& str : v) {
		std::cout << str << '\n';
	}


	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 3:50:50 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나

int main()
{
	std::vector<int> v;

	std::cout << "현재 원소 개수 - " << v.size() << '\n';
	std::cout << "재할당하지 않고 담을 수 있는 최대 원소 개수 - " << v.capacity() << '\n';
	std::cout << "v가 관리하는 메모리 - " << v.data() << '\n';

	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 3:51:46 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나

int main()
{
	std::vector<int> v;

	std::cout << "현재 원소 개수 - " << v.size() << '\n';
	std::cout << "용량			 - " << v.capacity() << '\n';
	std::cout << "메모리		 - " << v.data() << '\n';

	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 3:52:36 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나

int main()
{
	std::vector<int> v;

	std::cout << "현재 원소 개수 - " << v.size() << '\n';
	std::cout << "용량           - " << v.capacity() << '\n';
	std::cout << "메모리         - " << v.data() << '\n';

	v.push_back(1);
	
	std::cout << "원소를 한 개 추가한 후 v의 내용" << v.size() << '\n';

	std::cout << "현재 원소 개수 - " << v.size() << '\n';
	std::cout << "용량           - " << v.capacity() << '\n';
	std::cout << "메모리         - " << v.data() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:02:55 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나

int main()
{
	std::vector<int> v;

	std::cout << "현재 원소 개수 - " << v.size() << '\n';
	std::cout << "용량           - " << v.capacity() << '\n';
	std::cout << "메모리         - " << v.data() << '\n';

	v.push_back(1);
	v.push_back(2);

	std::cout << "원소를 한 개 추가한 후 v의 내용" << v.size() << '\n';

	std::cout << "현재 원소 개수 - " << v.size() << '\n';
	std::cout << "용량           - " << v.capacity() << '\n';
	std::cout << "메모리         - " << v.data() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:03:09 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나

int main()
{
	std::vector<int> v;

	std::cout << "현재 원소 개수 - " << v.size() << '\n';
	std::cout << "용량           - " << v.capacity() << '\n';
	std::cout << "메모리         - " << v.data() << '\n';

	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	//v.push_back(1);

	std::cout << "원소를 한 개 추가한 후 v의 내용" << v.size() << '\n';

	std::cout << "현재 원소 개수 - " << v.size() << '\n';
	std::cout << "용량           - " << v.capacity() << '\n';
	std::cout << "메모리         - " << v.data() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:03:18 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나

int main()
{
	std::vector<int> v;

	std::cout << "현재 원소 개수 - " << v.size() << '\n';
	std::cout << "용량           - " << v.capacity() << '\n';
	std::cout << "메모리         - " << v.data() << '\n';

	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	v.push_back(4);

	std::cout << "원소를 한 개 추가한 후 v의 내용" << v.size() << '\n';

	std::cout << "현재 원소 개수 - " << v.size() << '\n';
	std::cout << "용량           - " << v.capacity() << '\n';
	std::cout << "메모리         - " << v.data() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:04:03 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나

int main()
{
	for (int i = 0; i < 10; ++i) {
		std::vector<int> v;

		std::cout << "현재 원소 개수 - " << v.size() << '\n';
		std::cout << "용량           - " << v.capacity() << '\n';
		std::cout << "메모리         - " << v.data() << '\n';

		v.push_back(1);
		std::cout << "원소를 한 개 추가한 후 v의 내용" << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:04:31 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나

int main()
{

	std::vector<int> v;

	for (int i = 0; i < 10; ++i) {
		std::cout << "-----------------------------" << '\n';
		std::cout << "현재 원소 개수 - " << v.size() << '\n';
		std::cout << "용량           - " << v.capacity() << '\n';
		std::cout << "메모리         - " << v.data() << '\n';

		v.push_back(1);
		std::cout << "원소를 한 개 추가한 후 v의 내용" << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:04:58 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나

int main()
{

	std::vector<int> v;

	for (int i = 0; i < 10; ++i) {
		std::cout << "-----------------------------" << '\n';
		std::cout << "현재 원소 개수 - " << v.size() << '\n';
		std::cout << "용량           - " << v.capacity() << '\n';
		std::cout << "메모리         - " << v.data() << '\n';

		v.push_back(i);
		std::cout << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:05:19 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나

int main()
{

	std::vector<int> v;

	for (int i = 0; i < 20; ++i) {
		std::cout << "-----------------------------" << '\n';
		std::cout << "현재 원소 개수 - " << v.size() << '\n';
		std::cout << "용량           - " << v.capacity() << '\n';
		std::cout << "메모리         - " << v.data() << '\n';

		v.push_back(i);
		std::cout << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:06:57 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나

int main()
{

	std::vector<int> v;

	for (int i = 0; i < 30; ++i) {
		std::cout << "-----------------------------" << '\n';
		std::cout << "현재 원소 개수 - " << v.size() << '\n';
		std::cout << "용량           - " << v.capacity() << '\n';
		std::cout << "메모리         - " << v.data() << '\n';

		v.push_back(i);
		std::cout << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:17:10 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나
// 새로 메모리를 잡는 순간만 화면에 출력

int main()
{

	std::vector<int> v;

	size_t old = v.capacity();
	for (int i = 0; i < 1'0000; ++i) {

		v.push_back(i);

		if ( v.capacity() != old ) {
			std::cout << "원소 수 - " << v.size() << '\n';
			std::cout << "용량    - " << v.capacity() << '\n';
			old = v.capacity();
		}

	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:18:34 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 15일 화요일				(7주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나
// 새로 메모리를 잡는 순간만 화면에 출력

int main()
{

	std::vector<int> v;

	size_t old = v.capacity();
	for (int i = 0; i < 1'0000; ++i) {

		v.push_back(i);

		if ( v.capacity() != old ) {
			std::cout << "용량    - " << v.capacity() << '\n';
			old = v.capacity();
		}

	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:18:58 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 17일 화요일				(7주 2일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나
// 새로 메모리를 잡는 순간만 화면에 출력

int main()
{

	std::vector<int> v;

	size_t old = v.capacity();
	for (int i = 0; i < 1000'0000; ++i) {

		v.push_back(i);

		if ( v.capacity() != old ) {
			std::cout << "용량    - " << v.capacity() << '\n';
			old = v.capacity();
		}

	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:30:22 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 17일 화요일				(7주 2일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나
// 새로 메모리를 잡는 순간만 화면에 출력

int main()
{
	watching = true;

	std::vector<STRING> v;

	v.push_back(STRING("12345"));

	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:31:50 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 17일 화요일				(7주 2일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나
// 새로 메모리를 잡는 순간만 화면에 출력

int main()
{
	watching = true;

	std::vector<STRING> v;

	v.push_back(STRING("12345"));

	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:34:18 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 17일 화요일				(7주 2일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나
// 새로 메모리를 잡는 순간만 화면에 출력

int main()
{
	watching = true;

	std::vector<STRING> v;

	v.push_back(STRING("12345"));
	std::cout << v.back().getID()<<'\n';
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:34:46 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 17일 화요일				(7주 2일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나
// 새로 메모리를 잡는 순간만 화면에 출력

int main()
{
	watching = true;

	std::vector<STRING> v;

	v.push_back(STRING("12345"));
	std::cout << "v.back()에 들어간 STRING의 ID - " << v.back().getID() << '\n';
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:38:16 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 17일 화요일				(7주 2일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나
// 새로 메모리를 잡는 순간만 화면에 출력

int main()
{
	watching = true;

	std::vector<STRING> v;

	v.push_back(STRING("12345"));
	std::cout << "v.back()에 들어간 STRING의 ID - " << v.back().getID() << '\n';
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:39:06 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 17일 화요일				(7주 2일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나
// 새로 메모리를 잡는 순간만 화면에 출력

int main()
{
	watching = true;

	std::vector<STRING> v;

	v.push_back(STRING("12345"));
	std::cout << "v.back()에 들어간 STRING의 ID - " << v.back().getID() << '\n';
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 4:44:40 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 17일 화요일				(7주 2일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나
// 새로 메모리를 잡는 순간만 화면에 출력

int main()
{
	watching = true;

	std::vector<STRING> v;

	v.emplace_back(STRING("12345"));
	std::cout << "v.back()에 들어간 STRING의 ID - " << v.back().getID() << '\n';
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-17 오후 5:02:17 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 17일 화요일				(7주 2일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정) 
// 두 코드의 시간을 재고 비교해서 뭐가 더 빠르고 왜 빠른지 다루는 문제?
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] vector는 어떻게 메모리를 관리하나
// 새로 메모리를 잡는 순간만 화면에 출력

int main()
{
	watching = true;

	std::vector<STRING> v;

	v.emplace_back("12345");
	std::cout << "v.back()에 들어간 STRING의 ID - " << v.back().getID() << '\n';
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 1:45:09 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	watching = true;

	std::vector<STRING> v;

	// v에 최대 얼마만큼의 원소를 저장할 것인지 예측
	// 예측한 만큼 공간을 확보한다 -> reserve

	v.reserve(1'000);

	
	std::array<size_t, 26> frequency {};

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}

	char a;
	while (in >> a) {
		if ('a' << a and a << 'z') {
			++frequency[a - 'a'];
		}
	}

	for (a = 'a'; a != 'z' + 1; ++a) {
		std::cout << a << " - " << frequency[a - 'a'] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 1:45:23 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	watching = true;

	std::vector<STRING> v;

	// v에 최대 얼마만큼의 원소를 저장할 것인지 예측
	// 예측한 만큼 공간을 확보한다 -> reserve

	v.reserve(1'000);

	
	std::array<size_t, 26> frequency {};

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}

	char a;
	while (in >> a) {
		if ('a' < a and a < 'z') {
			++frequency[a - 'a'];
		}
	}

	for (a = 'a'; a != 'z' + 1; ++a) {
		std::cout << a << " - " << frequency[a - 'a'] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 1:46:02 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	watching = true;

	std::vector<STRING> v;

	// v에 최대 얼마만큼의 원소를 저장할 것인지 예측
	// 예측한 만큼 공간을 확보한다 -> reserve

	v.reserve(1'000);

	
	std::array<size_t, 26> frequency {};

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}

	char a;
	while (in >> a) {
		if ('a' <= a and a <= 'z') {
			++frequency[a - 'a'];
		}
	}

	for (a = 'a'; a != 'z' + 1; ++a) {
		std::cout << a << " - " << frequency[a - 'a'] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 1:46:17 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	watching = true;

	std::vector<STRING> v;

	// v에 최대 얼마만큼의 원소를 저장할 것인지 예측
	// 예측한 만큼 공간을 확보한다 -> reserve

	v.reserve(1'000);

	
	std::array<size_t, 26> frequency {};

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}

	char a;
	while (in >> a) {
		if ('a' <= a and a <= 'z') {
			++frequency[a - 'a'];
		}
	}

	for (a = 'a'; a != 'z' + 1; ++a) {
		std::cout << a << " - " << frequency[a - 'a'] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 1:49:50 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	watching = true;

	std::vector<STRING> v;

	// v에 최대 얼마만큼의 원소를 저장할 것인지 예측
	// 예측한 만큼 공간을 확보한다 -> reserve

	v.reserve(1'000);

	
	std::array<size_t, 26> frequency{};

	for (const size_t& size : frequency) {
		std::cout << size << ' ';
	}

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}

	char a;
	while (in >> a) {
		if ('a' <= a and a <= 'z') {
			++frequency[a - 'a'];
		}
	}

	for (a = 'a'; a != 'z' + 1; ++a) {
		std::cout << a << " - " << frequency[a - 'a'] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 1:50:00 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	watching = true;

	std::vector<STRING> v;

	// v에 최대 얼마만큼의 원소를 저장할 것인지 예측
	// 예측한 만큼 공간을 확보한다 -> reserve

	v.reserve(1'000);

	
	std::array<size_t, 26> frequency;

	for (const size_t& size : frequency) {
		std::cout << size << ' ';
	}

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}

	char a;
	while (in >> a) {
		if ('a' <= a and a <= 'z') {
			++frequency[a - 'a'];
		}
	}

	for (a = 'a'; a != 'z' + 1; ++a) {
		std::cout << a << " - " << frequency[a - 'a'] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 1:53:29 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	watching = true;

	std::vector<STRING> v;

	// v에 최대 얼마만큼의 원소를 저장할 것인지 예측
	// 예측한 만큼 공간을 확보한다 -> reserve

	v.reserve(1'000);

	
	std::array<size_t, 26> frequency{};

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}

	char a;
	while (in >> a) {
		if (islower(a)) {
			frequency[a - 'a']++;
		}
	}

	for (int i = 0; i < frequency.size(); ++i) {
		std::cout << static_cast<char>(i + 'a') << " -> " << frequency[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 1:58:13 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	std::vector<int> v {1, 2, 3, 4, 5};

	// [문제] v에서 3을 제거하라

	std::remove(v.begin(), v.end(), 3);

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 1:58:38 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	std::vector<int> v {1, 2, 3, 4, 5};

	// [문제] v에서 3을 제거하라

	std::remove(v.begin(), v.end(), 3);

	for (const int& a : v) {
		std::cout << a << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:07:52 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	std::vector<int> v {1, 2, 3, 4, 5};

	// [문제] v에서 3을 제거하라

	auto new_end =std::remove(v.begin(), v.end(), 3);
	v.erase(new_end, v.end());

	for (const int& a : v) {
		std::cout << a << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:09:36 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	std::vector<int> v {1, 2, 3, 4, 5};

	// [문제] v에서 3을 제거하라	erase-remove idiom

	v.erase(std::remove(v.begin(), v.end(), 3), v.end());

	for (const int& a : v) {
		std::cout << a << '\n';
	}
	std::cout << v.size() << '/' << v.capacity();

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:10:59 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	std::vector<int> v {1, 2, 3, 4, 5};

	// [문제] v에서 3을 제거하라	erase-remove idiom

	erase(v, 3);

	for (const int& a : v) {
		std::cout << a << '\n';
	}
	std::cout << v.size() << '/' << v.capacity() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:11:34 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	std::vector<int> v {1, 2, 3, 4, 5};

	// [문제] v에서 3을 제거하라	erase-remove idiom

	erase(v, 3);			// 알아만 둬라

	for (const int& a : v) {
		std::cout << a << '\n';
	}
	std::cout << v.size() << '/' << v.capacity() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:14:06 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	std::vector<int> v {1, 2, 3, 4, 5};

	// [문제] v에서 홀수를 제거하라	erase-remove idiom

	v.erase(std::remove_if(v.begin(), v.end(), [](const int& a) {
		return (a % 2 == 1);
		}),v.end());

	for (const int& a : v) {
		std::cout << a << '\n';
	}
	std::cout << v.size() << '/' << v.capacity() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:24:11 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	std::vector<int> v {1, 2, 3, 4, 5};

	// [문제] v에서 홀수를 제거하라	erase-remove idiom

	v.erase(std::remove_if(v.begin(), v.end(), [](const int& a) {
		return a & 11;
		}),v.end());

	for (const int& a : v) {
		std::cout << a << '\n';
	}
	std::cout << v.size() << '/' << v.capacity() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:24:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	std::vector<int> v {1, 2, 3, 4, 5,6, 7,8,9,10};

	// [문제] v에서 홀수를 제거하라	erase-remove idiom

	v.erase(std::remove_if(v.begin(), v.end(), [](const int& a) {
		return a & 11;
		}),v.end());

	for (const int& a : v) {
		std::cout << a << '\n';
	}
	std::cout << v.size() << '/' << v.capacity() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:24:46 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	std::vector<int> v {1, 2, 3, 4, 5,6, 7,8,9,10};

	// [문제] v에서 홀수를 제거하라	erase-remove idiom

	v.erase(std::remove_if(v.begin(), v.end(), [](const int& a) {
		return a & 1;
		}),v.end());

	for (const int& a : v) {
		std::cout << a << '\n';
	}
	std::cout << v.size() << '/' << v.capacity() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:24:56 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// [문제] "메인.cpp" 파일의 소문자 알파벳 빈도(frequency)를 다음과 같이 출력하라
// a -> 10
// b -> 3
// z -> 0

int main()
{
	std::vector<int> v {1, 2, 3, 4, 5,6, 7,8,9,10};

	// [문제] v에서 홀수를 제거하라	erase-remove idiom

	v.erase(std::remove_if(v.begin(), v.end(), [](const int& a) {
		return a & 11;
		}),v.end());

	for (const int& a : v) {
		std::cout << a << '\n';
	}
	std::cout << v.size() << '/' << v.capacity() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:36:04 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	std::vector<STRING> v{ "1", "2", "3", "4", "5" };

	// [문제] v에서 "3"을 제거하라

	v.erase(std::remove_if(v.begin(), v.end(), [](const STRING& s) {
		return s == STRING("3");

		
		}), v.end());

	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:36:33 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	std::vector<STRING> v{ "1", "2", "3", "4", "5" };

	// [문제] v에서 "3"을 제거하라

	v.erase(std::remove_if(v.begin(), v.end(), [](const STRING& s) {
		return s == STRING("3");

		
		}), v.end());

	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:40:50 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	std::vector<STRING> v{ "1", "2", "3", "4", "5" };

	// [문제] v에서 "3"을 제거하라

	v.erase(std::remove_if(v.begin(), v.end(), [](const STRING& s) {
		return s == STRING("3");

		
		}), v.end());

	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:41:53 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	std::vector<STRING> v{ "1", "2", "3", "4", "5" };

	// [문제] v에서 "3"을 제거하라

	v.erase(std::remove(v.begin(), v.end(), "3"),v.end());

	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:43:55 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	std::vector<STRING> v{ "1", "2", "4", "5" };

	// [문제] v에서 "2"와 "4"사이에 "3"을 삽입하라

	v.erase(std::remove(v.begin(), v.end(), "3"),v.end());

	v.insert(v.begin() + 2, "3");


	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:44:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	watching = true;
	std::vector<STRING> v{ "1", "2", "4", "5" };

	// [문제] v에서 "2"와 "4"사이에 "3"을 삽입하라

	v.erase(std::remove(v.begin(), v.end(), "3"),v.end());

	std::cout << "========";
	v.insert(v.begin() + 2, "3");
	std::cout << "========";
	
	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:45:18 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	watching = true;
	std::vector<STRING> v{ "1", "2", "4", "5" };

	// [문제] v에서 "2"와 "4"사이에 "3"을 삽입하라

	v.erase(std::remove(v.begin(), v.end(), "3"),v.end());

	std::cout << "========";
	v.insert(v.begin() + 2, "3");
	std::cout << "========";
	
	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:46:18 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	watching = true;
	std::vector<STRING> v{ "1", "2", "4", "5" };

	// [문제] v에서 "2"와 "4"사이에 "3"을 삽입하라
	std::cout << "========";
	v.erase(std::remove(v.begin(), v.end(), "3"),v.end());

	std::cout << "========";
	v.insert(v.begin() + 2, "3");
	std::cout << "========";
	
	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:47:01 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	watching = true;
	std::vector<STRING> v{ "1", "2", "4", "5" };

	// [문제] v에서 "2"와 "4"사이에 "3"을 삽입하라
	std::cout << "========";
	v.erase(std::remove(v.begin(), v.end(), "3"),v.end());

	std::cout << "========";
	v.insert(v.begin() + 2, "3");
	std::cout << "========";
	
	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:49:10 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	watching = true;
	std::vector<STRING> v{ "1", "2", "3", "4", "5" };

	// [문제] v에서 "2"와 "4"사이에 "3"을 삽입하라
	std::cout << "========";
	v.erase(std::remove(v.begin(), v.end(), "3"),v.end());

	std::cout << "========";
	v.insert(v.begin() + 2, "3");
	std::cout << "========";
	
	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:51:04 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	watching = true;
	std::list<STRING> v{ "1", "2", "3", "4", "5" };

	// [문제] v에서 "2"와 "4"사이에 "3"을 삽입하라
	std::cout << "========";
	std::remove(v.begin(), v.end(), "3"),v.end();

	/*std::cout << "========";
	v.insert(v.begin() + 2, "3");
	std::cout << "========";*/
	
	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:51:42 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	
	std::list<STRING> v{ "1", "22", "333", "4444", "55555" };

	// [문제] v에서 "2"와 "4"사이에 "3"을 삽입하라
	std::cout << "========";
	watching = true;
	std::remove(v.begin(), v.end(), "3"),v.end();
	watching = false;
	/*std::cout << "========";
	v.insert(v.begin() + 2, "3");
	std::cout << "========";*/
	
	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:52:19 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	
	std::list<STRING> v{ "1", "22", "333", "4444", "55555" };

	// [문제] v에서 "333"을 제거하라

	watching = true;
	std::remove(v.begin(), v.end(), "3"),v.end();
	watching = false;
	
	
	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:52:42 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	
	std::list<STRING> v{ "1", "22", "333", "4444", "55555" };

	// [문제] v에서 "333"을 제거하라

	watching = true;
	std::remove(v.begin(), v.end(), "333"),v.end();
	watching = false;
	
	
	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:54:04 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	
	std::list<STRING> v{ "1", "22", "4444", "55555" };

	// [문제] v에서 "333"을 삽입하라

	watching = true;
	v.insert(++++v.begin(), "333");
	watching = false;
	
	
	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:55:36 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	
	std::list<STRING> v{ "1", "22", "4444", "55555" };

	// [문제] v에서 "333"을 삽입하라
	STRING temp{ "333" };
	watching = true;

	v.insert(++ ++v.begin(),temp) ;
	watching = false;
	
	
	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 2:55:53 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	
	std::list<STRING> v{ "1", "22", "4444", "55555" };

	// [문제] v에서 "333"을 삽입하라

	watching = true;

	v.emplace(++ ++v.begin(),"333");
	watching = false;
	
	
	for (const STRING& s : v) {
		std::cout << s << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 3:00:31 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	std::deque<STRING> d;

	std::cout << "VS에서 x64일때 deque의 크기" << sizeof d << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 3:02:18 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	std::deque<STRING> d{ "1","22","333","4444","55555" };

	for (int i = 0; i < d.size(); ++i) {
		std::cout << &d[i] << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 3:03:17 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	watching = true;
	std::deque<STRING> d{ "1","22","333","4444","55555" };
	
	for (int i = 0; i < d.size(); ++i) {
		std::cout << &d[i] << '\n';
	}
	watching = false;
	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 3:06:07 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	watching = true;
	std::deque<STRING> d{ "1","22","333","4444" };

	d.push_front("0");
	d.push_front("-1");

	for (int i = 0; i < d.size(); ++i) {
		std::cout << &d[i] << '\n';
	}

	watching = false;
	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 3:06:22 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	watching = true;
	std::deque<STRING> d{ "1","22","333","4444" };

	d.push_front("0");
	d.push_front("-1");

	for (int i = 0; i < d.size(); ++i) {
		std::cout << d[i] << '\n';
	}

	watching = false;
	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-22 오후 3:07:44 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	watching = true;
	std::deque<STRING> d{ "1","22","333","4444" };

	for (const STRING& s : d) {
		std::cout << (void*)&s << '\n';
	}

	watching = false;
	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-29 오후 2:29:41 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	//watching = true;
	std::vector<STRING> v{ "1", "222", "333", "4444", "55555" };
	std::erase(v, "333");
	//watching = false;

	for (const STRING& s : v) {
		std::cout << s << '\n';
	}
	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-29 오후 2:29:54 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	watching = true;
	std::vector<STRING> v{ "1", "222", "333", "4444", "55555" };
	std::erase(v, "333");
	watching = false;

	for (const STRING& s : v) {
		std::cout << s << '\n';
	}
	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-29 오후 2:30:08 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	
	std::vector<STRING> v{ "1", "222", "333", "4444", "55555" };

	watching = true;
	std::erase(v, "333");
	watching = false;

	for (const STRING& s : v) {
		std::cout << s << '\n';
	}
	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-29 오후 2:31:13 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	
	std::list<STRING> v{ "1", "222", "333", "4444", "55555" };

	watching = true;
	std::erase(v, "333");
	watching = false;

	for (const STRING& s : v) {
		std::cout << s << '\n';
	}
	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-29 오후 2:45:03 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	
	std::list<STRING> v{ "1", "222", "333", "4444", "55555" };

	watching = true;
	v.remove("333");
	watching = false;

	for (const STRING& s : v) {
		std::cout << s << '\n';
	}
	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-29 오후 3:07:10 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	watching = true;

	std::list<STRING> cont { "1", "333", "22", "4444", "55555" };


	for (const STRING str : cont) {
		std::cout << str << '\n';
	}

	watching = false;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-04-29 오후 3:07:40 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	watching = true;

	std::list<STRING> cont { "1", "333", "22", "4444", "55555" };


	for (const STRING& str : cont) {
		std::cout << str << '\n';
	}

	watching = false;

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 3:34:13 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

// a & 1

int main()
{
	std::vector<int> v;

	std::cout << "최대 개수 - " << v.max_size() << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 3:40:30 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

class Test {
	char x[1'000'000];
};

int main()
{
	{
		std::vector<Test> v;
		try {
			
			while (true) {
				v.emplace_back();
			}
		}
		catch ( ... ) {
			std::cout << "최대 원수 수 - " << v.size();
		}
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 3:41:46 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

class Test {
	char x[1'000'000];
};

int main()
{
	{
		std::vector<Test> v;
		try {
			
			while (true) {
				v.emplace_back();
			}
		}
		catch (...) {
			std::cout << "최대 원수 수 - " << v.size() << "\n";
		}
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 3:43:57 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

class Test {
	char x[1'000'000];
};

int main()
{
	{	// 40965
		std::vector<Test> v;
		try {
			
			while (true) {
				v.emplace_back();
			}
		}
		catch (...) {
			std::cout << "최대 원수 수 - " << v.size() << "\n";
		}
	}

	{	// 
		std::deque<Test> d;
		try {

			while (true) {
				d.emplace_back();
			}
		}
		catch (...) {
			std::cout << "최대 원수 수 - " << d.size() << "\n";
		}
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 3:50:47 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <ranges>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::list<int> cont{ 1,2,3,4,5,6,7,8,9,10 };

	// [문제] cont의 두번째 원소부터 끝까지를 출력하라

	for (const int& i : cont | std::views::drop(1)) {
		std::cout << i << " ";
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 3:52:56 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::list<int> cont{ 1,2,3,4,5,6,7,8,9,10 };

	// [문제] cont의 두번째 원소부터 끝까지를 출력하라

	for (auto it = ++cont.begin(); it != cont.end(); ++it) {
		std::cout << *it << " ";
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 4:02:58 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::list<int> cont{ 1,2,3,4,5,6,7,8,9,10 };

	// [문제] cont의 두번째 원소부터 끝까지를 출력하라

	for (auto it = ++cont.begin(); it != cont.end(); ++it) {
		std::cout << *it << " ";
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 4:07:09 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::list<int> cont{ 1,2,3,4,5,6,7,8,9,10 };

	// [문제] cont의 원소를 거꾸로 출력하시오

	for (auto it = cont.rbegin(); it != cont.rend(); ++it) {
		std::cout << *it << " ";
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 4:07:56 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::list<int> cont{ 1,3,5,7,9,2,4,6,8 };

	// [문제] cont의 원소를 거꾸로 출력하시오

	for (auto it = cont.rbegin(); it != cont.rend(); ++it) {
		std::cout << *it << " ";
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 4:08:55 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <unordered_set>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::unordered_set<int> cont{ 1,3,5,7,9,2,4,6,8 };

	// [문제] cont의 원소를 거꾸로 출력하시오

	for (auto it = cont.begin(); it != cont.end(); ++it) {
		std::cout << *it << " ";
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 4:09:24 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::vector<int> cont{ 1,3,5,7,9,2,4,6,8 };

	// [문제] cont의 원소를 거꾸로 출력하시오

	for (auto it = cont.begin(); it != cont.end(); ++it) {
		std::cout << *it << " ";
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 4:09:38 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <set>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::set<int> cont{ 1,3,5,7,9,2,4,6,8 };

	// [문제] cont의 원소를 거꾸로 출력하시오

	for (auto it = cont.begin(); it != cont.end(); ++it) {
		std::cout << *it << " ";
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 4:39:03 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.

	std::list<STRING> words;

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}
	
	STRING str;
	while (in >> str) {
		words.push_back(str);
	}

	for (const STRING& word : words) {
		std::cout << word << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 4:39:31 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.

	std::list<STRING> words;

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}
	
	STRING str;
	while (in >> str) {
		words.push_back(str);
	}

	for (const STRING& word : words) {
		std::cout << word << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 4:39:47 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.

	std::list<STRING> words;

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}
	
	STRING str;
	while (in >> str) {
		words.push_back(str);
	}

	for (const STRING& word : words) {
		std::cout << word << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 4:40:13 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.

	std::list<STRING> words;

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}
	
	STRING str;
	while (in >> str) {
		words.push_back(str);
	}

	for (const STRING& word : words) {
		std::cout << word << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-01 오후 4:45:53 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	4월 22일 화요일				(8주 1일)
// 중간고사	(30) - 4월 24일 목요일 - 시험 장소 : E동 320호
// 5월 6일 (화요일) -> 6월 19일(예정)
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	// [문제] "메인.cpp"의 단어를 list에 저장하라.
	// 찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.

	std::list<STRING> words;

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}
	
	STRING str;
	while (in >> str) {
		words.push_back(str);
	}

	for (const STRING& word : words) {
		std::cout << word << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:07:59 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}

	std::list<STRING> words{ std::istream_iterator<STRING>(in), {} };

	// [문제] 길이가 5인 단어만 화면에 출력하라

	for (const STRING& word : words) {
		if (word.size() == 5) {
			std::cout << word << '\n';
		}
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:18:00 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}

	std::list<STRING> words{ std::istream_iterator<STRING>(in), {} };

	// [문제] 길이가 5인 단어만 화면에 출력하라
	
	auto p = std::find_if(words.begin(), words.end(), [](const STRING& word) {
		return 5 == word.size();
		});
	if (p != words.end()) {
		std::cout << *p << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:24:19 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}

	std::list<STRING> words{ std::istream_iterator<STRING>(in), {} };

	// [문제] 길이가 5인 단어만 화면에 출력하라
	
	std::copy(words.begin(), words.end(), std::ostream_iterator<STRING>{std::cout});

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:24:51 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}

	std::list<STRING> words{ std::istream_iterator<STRING>(in), {} };

	// [문제] 길이가 5인 단어만 화면에 출력하라
	
	std::copy(words.begin(), words.end(), std::ostream_iterator<STRING>{std::cout,"\n"});

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:26:48 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}

	std::list<STRING> words{ std::istream_iterator<STRING>(in), {} };

	// [문제] 길이가 5인 단어만 화면에 출력하라
	
	std::copy_if(words.begin(), words.end(), std::ostream_iterator<STRING>{std::cout, "\n"}, [](const STRING& word) {
		return 5 == word.size();
		});

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:27:55 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	std::ifstream in{ "main.cpp" };
	if (not in) {
		return -1557;
	}

	std::list<STRING> words{ std::istream_iterator<STRING>(in), {} };

	// [문제] 길이가 5인 단어만 화면에 출력하라
	
	std::copy_if(words.begin(), words.end(), std::ostream_iterator<STRING>{std::cout, "\n"}, [](const STRING& word) {
		return 5 == word.size();
		});

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:34:10 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				- sort(), unique(), merge(), splice()
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::list<std::string> list1{ "1", "55555", "333" };
	std::list<std::string> list2{ "4444", "22" };

	list1.merge(list2);

	for (const std::string& word : list1) {
		std::cout << word << '\n';
	}

	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:34:19 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				- sort(), unique(), merge(), splice()
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::list<std::string> list1{ "1", "55555", "333" };
	std::list<std::string> list2{ "4444", "22" };

	list1.merge(list2);

	for (const std::string& word : list1) {
		std::cout << word << '\n';
	}

	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:34:58 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				- sort(), unique(), merge(), splice()
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::list<std::string> list1{ "1", "55555", "333" };
	std::list<std::string> list2{ "4444", "22" };

	list1.merge(list2);

	for (const std::string& word : list1) {
		std::cout << word << '\n';
	}
	for (const std::string& word : list2) {
		std::cout << word << '\n';
	}
	

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:35:23 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				- sort(), unique(), merge(), splice()
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::list<std::string> list1{ "1", "55555", "333" };
	std::list<std::string> list2{ "4444", "22" };

	list1.merge(list2);

	for (const std::string& word : list1) {
		std::cout << word << ' ';
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:38:15 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				- sort(), unique(), merge(), splice()
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::list<std::string> list1{ "1", "55555", "333" };
	std::list<std::string> list2{ "4444", "22" };

	list1.sort();
	list2.sort();

	list1.merge(list2);

	for (const std::string& word : list1) {
		std::cout << word << ' ';
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:44:10 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				- sort(), unique(), merge(), splice()
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::list<STRING> list1{ "1", "55555", "333" };
	std::list<STRING> list2{ "4444", "22" };

	list1.sort();
	list2.sort();

	list1.merge(list2);

	for (const STRING& word : list1) {
		std::cout << word << ' ';
	}
	std::cout << '\n';

	for (const STRING& word : list2) {
		std::cout << word << ' ';
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:45:27 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				- sort(), unique(), merge(), splice()
//------------------------------------------------------------------
#include <iostream>
#include <list>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::list<STRING> list1{ "1", "55555", "333" };
	std::list<STRING> list2{ "4444", "22" };
	watching = true;
	list1.sort();
	list2.sort();

	list1.merge(list2);
	watching = false;
	for (const STRING& word : list1) {
		std::cout << word << ' ';
	}
	std::cout << '\n';

	for (const STRING& word : list2) {
		std::cout << word << ' ';
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:56:41 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				- sort(), unique(), merge(), splice()
//		forward_list<T> -
//			It is intended that forward_list have zero space or time overhead
//			relative to a hand-written C-style singly linked list.
//			Features that would conflict with that goal have been omitted.
//------------------------------------------------------------------
#include <iostream>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::forward_list<STRING> cont;

	std::cout << sizeof(cont) << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 4:56:54 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				- sort(), unique(), merge(), splice()
//		forward_list<T> -
//			It is intended that forward_list have zero space or time overhead
//			relative to a hand-written C-style singly linked list.
//			Features that would conflict with that goal have been omitted.
//------------------------------------------------------------------
#include <iostream>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::forward_list<STRING> cont;

	std::cout << sizeof cont << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 5:07:05 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				- sort(), unique(), merge(), splice()
//		forward_list<T> -
//			It is intended that forward_list have zero space or time overhead
//			relative to a hand-written C-style singly linked list.
//			Features that would conflict with that goal have been omitted.
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <vector>
#include <deque>
#include <span>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

void f(std::span<int> s)
{
	for (auto i = s.rbegin(); i != s.rend(); ++i) {
		std::cout << *i << " ";
	}
	std::cout << '\n';
}

int main()
{
	int a[]{ 1,2,3,4,5,6,7 };
	// 거꾸로 출력하라
	f(a);

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-08 오후 5:08:18 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 8일 목요일							(10주 1일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// STl Container - Containers are objects that store other objects.
// 1. Sequence Containers
//		array<T, N>
//		vector<T> - push_back() O(1)
//		deque<T> - push_front()/push_back() O(1)
//		list<T> - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//				- sort(), unique(), merge(), splice()
//		forward_list<T> -
//			It is intended that forward_list have zero space or time overhead
//			relative to a hand-written C-style singly linked list.
//			Features that would conflict with that goal have been omitted.
//------------------------------------------------------------------
#include <iostream>
#include <array>
#include <vector>
#include <deque>
#include <span>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

void f(std::span<int> s)
{
	for (auto i = s.rbegin(); i != s.rend(); ++i) {
		std::cout << *i << " ";
	}
	std::cout << '\n';
}

int main()
{
	int a[]{ 1,2,3,4,5,6,7 };
	// 거꾸로 출력하라
	f(a);

	std::vector<int> v{ std::begin(a), std::end(a) };// { &a[0], &[7] };
	f(v);

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 1:38:59 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정


int main()
{
	std::string s{ "2025 5 13" };

	std::cout << s << '\n';

	for (const char& c : s) {
		std::cout << c << " ";
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 1:52:41 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정


int main()
{
	STRING s{ "2025 5 13" };

	std::cout << s << '\n';

	// syntactic sugar
	for (char c : s) {
		std::cout << c << " ";
	}

	/*for (auto i = s.begin(); i != s.end(); ++i) {
		std::cout << *i << " ";
	}*/
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 2:10:58 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정


int main()
{
	// 반복자는 포인터를 일반화한 것이다.
	
	std::ostream_iterator<char> p { std::cout };

	*p = 'A';
	++p;
	*p = 'B';
	++p;
	*p = 'C';
	++p;
	*p = '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 2:15:22 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정


int main()
{
	// 반복자는 포인터를 일반화한 것이다.
	
	std::ostream_iterator<char> p { std::cout };

	p.operator*() = 'A';
	//p.operator++();
	*p = 'B';
	//++p;
	*p = 'C';
	//++p;
	*p = '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 2:31:04 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정


int main()
{
	// 반복자는 포인터를 일반화한 것이다.
	
	std::ostream_iterator<char> p { std::cout };

	p = 'A';
	p = 'B';
	p = 'C';
	p.operator=('A');
	p = '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 2:32:55 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정


int main()
{
	// 반복자는 포인터를 일반화한 것이다.
	
	std::string s { "2025 5 13" };

	// s를 거꾸로 출력하라.

	for ( const char& c : s) {
		std::cout << c;
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 2:36:55 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정


int main()
{
	// 반복자는 포인터를 일반화한 것이다.
	
	std::string s { "2025 5 13" };

	// s를 거꾸로 출력하라.

	for (auto i = s.rbegin(); i!=s.rend(); ++i) {
		std::cout << *i << '\n';
	}

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 2:37:29 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정


int main()
{
	// 반복자는 포인터를 일반화한 것이다.
	
	std::string s { "2025 5 13" };

	// s를 거꾸로 출력하라.

	for (auto i = s.rbegin(); i!=s.rend(); ++i) {
		std::cout << *i << ' ';
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 2:37:40 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정


int main()
{
	// 반복자는 포인터를 일반화한 것이다.
	
	std::string s { "2025 5 13" };

	// s를 거꾸로 출력하라.

	for (auto i = s.rbegin(); i!=s.rend(); ++i) {
		std::cout << *i;
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 3:02:28 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정


int main()
{
	// 반복자는 포인터를 일반화한 것이다.
	
	STRING s { "2025 5 13" };

	// s를 거꾸로 출력하라.

	for (auto i = s.rbegin(); i != s.rend(); ++i) {
		std::cout << *i;
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 3:02:57 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정


int main()
{
	// 반복자는 포인터를 일반화한 것이다.
	
	STRING s { "2025 5 13" };

	// s를 거꾸로 출력하라.

	for (auto i = s.rbegin(); i != s.rend(); ++i) {
		std::cout << *i;
	}
	std::cout << '\n';

	for (auto i = s.rbegin(); i != s.rend(); ++i) {
		std::cout << *i;
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 3:03:27 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정


int main()
{
	// 반복자는 포인터를 일반화한 것이다.
	
	STRING s { "2025 5 13" };

	// s를 거꾸로 출력하라.

	for (auto i = s.rbegin(); i != s.rend(); ++i) {
		std::cout << *i;
	}
	std::cout << '\n';

	for (auto i = s.rbegin(); i != s.rend(); ++i) {
		*i = 'A';
		std::cout << *i;
	}
	std::cout << '\n';

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 3:09:36 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

void f(std::array<int, 2>::iterator i)
{
	// 종류
	std::cout << "array의 반복자 - " << typeid(i).name() << '\n';
}

int main()
{
	// [문제] 반복자는 종류(6 category)가 있다.
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	// 다음 코드가 문제없이 실행되게 하자.

	//f(std::array<int, 0>::iterator{});
	std::array<int, 2> a;
	f(a.begin());

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 3:12:51 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "array의 반복자 - " << typeid(i).name() << '\n';
}

int main()
{
	// [문제] 반복자는 종류(6 category)가 있다.
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	// 다음 코드가 문제없이 실행되게 하자.

	//f(std::array<int, 0>::iterator{});
	std::array<int, 2> a;
	f(a.begin());

	std::vector<char> v;
	f(v.end());

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 3:13:35 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "array의 반복자 - " << typeid(Iterator).name() << '\n';
}

int main()
{
	// [문제] 반복자는 종류(6 category)가 있다.
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	// 다음 코드가 문제없이 실행되게 하자.

	//f(std::array<int, 0>::iterator{});
	std::array<int, 2> a;
	f(a.begin());

	std::vector<char> v;
	f(v.end());

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 3:14:12 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "반복자의 타입 - " << typeid(Iterator).name() << '\n';
}

int main()
{
	// [문제] 반복자는 종류(6 category)가 있다.
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	// 다음 코드가 문제없이 실행되게 하자.

	//f(std::array<int, 0>::iterator{});
	std::array<int, 2> a;
	f(a.begin());

	std::vector<char> v;
	f(v.end());

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 3:17:08 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "반복자의 타입 - " << typeid(Iterator::iterator_category).name() << '\n';
}

int main()
{
	// [문제] 반복자는 종류(6 category)가 있다.
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	// 다음 코드가 문제없이 실행되게 하자.

	//f(std::array<int, 0>::iterator{});
	std::array<int, 2> a;
	f(a.begin());

	std::vector<char> v;
	f(v.end());

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 3:18:55 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "반복자의 타입 - " << typeid(Iterator::iterator_category).name() << '\n';
}

int main()
{
	// [문제] 반복자는 종류(6 category)가 있다.
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	// 다음 코드가 문제없이 실행되게 하자.

	//f(std::array<int, 0>::iterator{});
	std::array<int, 2> a;
	f(a.begin());

	std::vector<char> v;
	f(v.end());

	f(std::deque<STRING>::iterator{});
	f(std::list<int>{}.rbegin());
	f(std::forward_list<int>::const_iterator{});


	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-13 오후 3:19:47 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "반복자의 타입 - " << typeid(Iterator::iterator_category).name() << '\n';
}

int main()
{
	// [문제] 반복자는 종류(6 category)가 있다.
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	// 다음 코드가 문제없이 실행되게 하자.

	//f(std::array<int, 0>::iterator{});
	std::array<int, 2> a;
	f(a.begin());

	std::vector<char> v;
	f(v.end());

	f(std::deque<STRING>::iterator{});
	f(std::list<int>{}.rbegin());
	f(std::forward_list<int>::const_iterator{});

	f(std::ostream_iterator<char>{std::cout});

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-15 오후 3:38:34 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "반복자의 타입 - " << typeid(Iterator::iterator_category).name() << '\n';
}

int main()
{
	// [문제] 반복자는 종류(6 category)가 있다.
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	// 다음 코드가 문제없이 실행되게 하자.

	//f(std::array<int, 0>::iterator{});
	std::array<int, 2> a;
	f(a.begin());

	std::vector<char> v;
	f(v.end());

	f(std::deque<STRING>::iterator{});
	f(std::list<int>{}.rbegin());
	f(std::forward_list<int>::const_iterator{});

	f(std::ostream_iterator<char>{std::cout});

	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-15 오후 3:42:33 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "반복자의 타입 - " << typeid(Iterator::iterator_category).name() << '\n';
}

int main()
{
	// [문제] 반복자는 종류(6 category)가 있다.
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	// 다음 코드가 문제없이 실행되게 하자.

	f(std::istream_iterator<char> {std::cin});
	f(std::ostream_iterator<char> {std::cout});

	f(std::forward_list<int> {}.begin());
	f(std::list<STRING>::iterator {});
	f(std::deque<int>::reverse_iterator{});
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-15 오후 3:43:36 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "반복자의 타입 - " << typeid(Iterator::iterator_category).name() << '\n';
}

int main()
{
	// [문제] 반복자는 종류(6 category)가 있다.
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	// 다음 코드가 문제없이 실행되게 하자.

	f(std::istream_iterator<char> {std::cin});
	f(std::ostream_iterator<char> {std::cout});

	f(std::forward_list<int> {}.begin());
	f(std::list<STRING>::iterator {});
	f(std::deque<int>::reverse_iterator{});
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-15 오후 3:44:15 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "반복자의 타입 - " << typeid(Iterator::iterator_category).name() << '\n';
}

int main()
{
	// [문제] 반복자는 종류(6 category)가 있다.
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	// 다음 코드가 문제없이 실행되게 하자.

	f(std::istream_iterator<char> {std::cin});
	f(std::ostream_iterator<char> {std::cout});

	f(std::forward_list<int> {}.begin());
	f(std::list<STRING>::iterator {});
	f(std::deque<int>::reverse_iterator{});
	f(std::vector<STRING>::iterator{});
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-15 오후 4:04:18 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "반복자의 타입 - " << typeid(std::iterator_traits<Iterator>::iterator_category).name() << '\n';
}

int main()
{
	// [문제] 반복자는 종류(6 category)가 있다.
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	// 다음 코드가 문제없이 실행되게 하자.

	int* p;

	f(p);
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-15 오후 4:14:55 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "반복자의 타입 - " << typeid(std::iterator_traits<Iterator>::iterator_category).name() << '\n';
}

int main()
{
	// [문제] 반복자는 종류(6 category)가 있다.
	// 함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	// 다음 코드가 문제없이 실행되게 하자.

	int* p;

	f(p);
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-15 오후 4:24:01 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "반복자의 타입 - " << typeid(std::iterator_traits<Iterator>::iterator_category).name() << '\n';


	// 벡터는 C++ 20의 concept을 이용하여 contiguous임을 판정한다.

}

int main()
{
	// vector는 진짜 메모리아 contigo\uosu한가
	// deuqu는 contig\uous

	f(std::vector<int> {}.begin());
	f(std::deque<int> {}.begin());
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-15 오후 4:26:25 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <string>
#include <iterator>
#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class Iterator>
void f(Iterator i)
{
	// 종류
	std::cout << "반복자의 타입 - " << typeid(std::iterator_traits<Iterator>::iterator_category).name() << '\n';


	// 벡터는 C++ 20의 concept을 이용하여 contiguous임을 판정한다.
	std::cout << "벡터의 반복자 - " << typeid(Iterator::iterator_concept).name() << '\n';
}

int main()
{
	// vector는 진짜 메모리가 contiguous한가
	// deuqu는 contiguous

	f(std::vector<int> {}.begin());
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-15 오후 4:33:42 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <concepts>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::vector<int> v;

	std::cout << std::boolalpha << std::contiguous_iterator<std::vector<int>::iterator> << '\n';
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-15 오후 4:34:31 목요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <concepts>
#include <deque>
#include "save.h"
#include "STRING.h"
// using namespace std;			// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{
	std::vector<int> v;

	std::cout << std::boolalpha << std::contiguous_iterator<std::deque<int>::iterator> << '\n';
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-19 오전 1:13:22 월요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	std::vector<int>::iterator{};

	STRING s{ "2025 5 15" };

	// 문제없이 실행되게 하자
	std::sort(s.begin(), s.end());

	std::cout << s << '\n';				// "   01225555"
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-19 오전 1:14:49 월요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	STRING s{ "2025 5 15" };

	// 문제없이 실행되게 하자
	std::sort(s.begin(), s.end());
	*(std::find(s.begin(), s.end(),'1')) = 'a';

	std::cout << s << '\n';				// "   01225555"
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-19 오후 1:05:31 월요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	STRING s{ "2025 5 15" };

	// 문제없이 실행되게 하자
	std::sort(s.begin(), s.end());
	*(std::find(s.begin(), s.end(),'1')) = 'a';

	std::cout << s << '\n';				// "   01225555"
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 1:45:46 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	STRING s{ "2025 5 15" };

	// 문제없이 실행되게 하자
	std::sort(s.begin(), s.end());
	*(std::find(s.begin(), s.end(),'1')) = 'a';

	std::cout << s << '\n';				// "   01225555"
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 2:05:31 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	STRING s{ "2025 5 15" };

	// 문제없이 실행되게 하자
	std::sort(s.begin(), s.end());


	std::cout << s << '\n';				// "   01225555"
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 2:08:30 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	STRING s{ "2025 5 15" };

	// 문제없이 실행되게 하자
	std::sort(s.begin(), s.end(), [](const char& lhs, const char& rhs) {
		return lhs > rhs;
		});
	

	std::cout << s << '\n';				// "   01225555"
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 2:08:42 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	STRING s{ "2025 5 20" };

	// 문제없이 실행되게 하자
	std::sort(s.begin(), s.end(), [](const char& lhs, const char& rhs) {
		return lhs > rhs;
		});
	

	std::cout << s << '\n';				// "   01225555"
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 2:09:57 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	STRING s{ "2025 5 20" };

	// 문제없이 실행되게 하자
	std::sort(s.begin(), s.end(), [](const char& lhs, const char& rhs) {
		return lhs > rhs;
		});
	*(std::find(s.begin(), s.end(), '2')) = 'k';

	std::cout << s << '\n';				// "   01225555"
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 2:37:51 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	STRING s{ "lazy fox jumps over the brown dog" };
	
	std::sort(s.begin(), s.end());

	std::cout << s << std::endl;
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 2:38:37 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	STRING s{ "The quick brown fox jumps over the lazy dog" };
	
	std::sort(s.begin(), s.end());

	std::cout << s << std::endl;
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 2:39:01 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	STRING s{ "the quick brown fox jumps over the lazy dog" };
	
	std::sort(s.begin(), s.end());

	std::cout << s << std::endl;
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 2:39:38 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	STRING s{ "the quick brown fox jumps over the lazy dog" };
	
	std::sort(s.begin(), s.end());
	std::unique(s.begin(), s.end());

	std::cout << s << std::endl;
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 2:40:04 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

int main()
{

	STRING s{ "the quick brown fox jumps over the lazy dog" };
	
	std::sort(s.begin(), s.end());
	std::unique(s.begin(), s.end());

	std::cout << s << std::endl;
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 3:01:43 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class 반복자, class 값>
반복자 my_find(반복자 b, 반복자 e, 값 v)
{
	while (b != e) {
		if (v == *b) {
			return b;
		}
		++b;
	}
	return b;
}

template<class 반복자, class 값>
반복자 myfind_if(반복자 b, 반복자 e, 값 v)
{
	while (b != e) {
		if (v(*b)) {
			return b;
		}
		++b;
	}
	return b;
}

int main()
{

	std::vector < int > v{ 2, 4, 7,5, 5,3,2 ,6, 1,8,0, 6,53 };

	// [문제] v에서 처음 나오는 짝수가 무엇인지 출력하라

	auto p = myfind_if(v.begin(), v.end(), [](int  n) {
		return not (n & 1);
	});

	if (p != v.end()) {
		std::cout << "처음 만난 짝수는 - " << *p;
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 3:02:07 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class 반복자, class 값>
반복자 my_find(반복자 b, 반복자 e, 값 v)
{
	while (b != e) {
		if (v == *b) {
			return b;
		}
		++b;
	}
	return b;
}

template<class 반복자, class 값>
반복자 myfind_if(반복자 b, 반복자 e, 값 v)
{
	while (b != e) {
		if (v(*b)) {
			return b;
		}
		++b;
	}
	return b;
}

int main()
{

	std::vector < int > v{ 1, 7, 3, 2, 4, 7,5, 5,3,2 ,6, 1,8,0, 6,53 };

	// [문제] v에서 처음 나오는 짝수가 무엇인지 출력하라
	
	auto p = myfind_if(v.begin(), v.end(), [](int  n) {
		return not (n & 1);
	});

	if (p != v.end()) {
		std::cout << "처음 만난 짝수는 - " << *p << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 3:06:33 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class 반복자, class 값>
반복자 my_find(반복자 b, 반복자 e, 값 v)
{
	while (b != e) {
		if (v == *b) {
			return b;
		}
		++b;
	}
	return b;
}

template<class 반복자, class Pred>
반복자 myfind_if(반복자 b, 반복자 e, Pred f)
{
	for (; b != e; ++b) {
		if (f(*b)) { return b; }
	}
	return e;
}

int main()
{

	std::vector < int > v{ 1, 7, 3, 2, 4, 7,5, 5,3,2 ,6, 1,8,0, 6,53 };

	// [문제] v에서 처음 나오는 짝수가 무엇인지 출력하라
	
	auto p = myfind_if(v.begin(), v.end(), [](int  n) {
		return not (n & 1);
	});

	if (p != v.end()) {
		std::cout << "처음 만난 짝수는 - " << *p << '\n';
	}
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 3:08:06 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class 반복자, class 값>
반복자 my_find(반복자 b, 반복자 e, 값 v)
{
	while (b != e) {
		if (v == *b) {
			return b;
		}
		++b;
	}
	return b;
}

template<class 반복자, class Pred>
반복자 myfind_if(반복자 b, 반복자 e, Pred f)
{
	for (; b != e; ++b) {
		if (f(*b)) { return b; }
	}
	return e;
}

int main()
{

	STRING s{ "반복자를 사용한 알고리즘을 연습 중" };
	std::vector<char> v;

	copy(s.begin(), s.end(), std::ostream_iterator<char>{std::cout});
	
	
	save("main.cpp");
}

=================================================
저장한 시간: 2025-05-20 오후 3:17:03 화요일
=================================================

//------------------------------------------------------------------
// 2025 STL 화56목78	5월 13일 화요일							(10주 2일)
// 6월 19일 목요일 15주 2일 - 기말 시험
//------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release / x64, C++언어표준 - /std::c++latest, SDL 검사 - 아니오
//------------------------------------------------------------------
// Iterator - Iterators are a generalization of pointers
//			  that allow a C++ program to work with different data structures in a uniform manner.
// 
// 반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"
// using namespace std;					// 우리는 이렇게 하면 안된다
// constexpr란?
// move semantic

extern bool watching;					// 관찰하려면 true로 설정

template<class 반복자, class 값>
반복자 my_find(반복자 b, 반복자 e, 값 v)
{
	while (b != e) {
		if (v == *b) {
			return b;
		}
		++b;
	}
	return b;
}

template<class 반복자, class Pred>
반복자 myfind_if(반복자 b, 반복자 e, Pred f)
{
	for (; b != e; ++b) {
		if (f(*b)) { return b; }
	}
	return e;
}

template<class 반복자, class 목적지반복자>
void my_copy(반복자 b, 반복자 e, 목적지반복자 d)
{
	while (b != e) {
		*d = *b;
		++d;
		++b;
	}
}

int main()
{

	STRING s{ "반복자를 사용한 알고리즘을 연습 중" };
	std::vector<char> v{ '1' };

	my_copy(s.begin(), s.end(), back_inserter(v));
	
	for (char c : v) {
		std::cout << c;
	}

	std::cout << '\n';

	save("main.cpp");
}